/*
 Generated by the generate_base script.  DO NOT EDIT!
*/
#include <string>
#include <Node/NodeApi.h>
#include <AmwTool/AbstractMessage.h>

#pragma pack(1) // Specify the alignment method as tight alignment
struct ${name}_t : public BaseServicePacket {
  ${name}_t():BaseServicePacket(&req,&resp){
	bzero((char *)&req +sizeof(int*),sizeof(req) - sizeof(int*));
	bzero((char*)&resp+sizeof(int*),sizeof(resp) - sizeof(int*));
}
${fields}${typedefs}
};
#pragma pack() // Restore default alignment

#ifdef __cplusplus
#ifdef ${md_prefix_ns_define}
namespace ${md_prefix_ns_define} {
#endif
${ns_opening}


class ${class_name} {
public:
 ${class_name}() : ppService(nullptr) {
 };
 virtual ~${class_name}() {
  unregister_${name}();
 }
private:
static int cb(const void *reqData,size_t reqLen, void **resData,size_t *resLen, void *user_data) {
  ${class_name}* self = (${class_name}*)user_data;
  ${name}_t tmpData;
  tmpData.m_req->deserializeFromArray(reqData,reqLen);
  int ret=self->on_${name}(tmpData);
  if(ret==0){
	tmpData.m_resp->serializeToArray(*resData,*resLen);
  }
  return ret;
}
 

public: 
void unregister_${name}() {
  if(nullptr!= ppService) {
	int ret=node_service_destroy(m_nodeName.c_str(),ppService);
	if(0!= ret) {
		fprintf(stderr, "ERROR: node_service_destroy() failed with error code %d\n", ret);
		return;
	}	
	ppService=nullptr;
  }
}
 
bool register_${name}(const std::string& nodeName,const std::string& serviceName) {
	m_nodeName = nodeName;
	m_serviceName = serviceName;
	if(nullptr== ppService) {
		int ret=node_service_create(m_nodeName.c_str(), m_serviceName.c_str(), &ppService);
		if(0!= ret) {
			fprintf(stderr, "[%s]-[%s]ERROR: node_service_create() failed with error code %d\n",nodeName.c_str(),serviceName.c_str(), ret);
			return false;
		}
		ret=node_service_set_handle(m_nodeName.c_str(),ppService, cb, (void *)this);
		if(0!= ret) {
			fprintf(stderr, "[%s]-[%s]ERROR: node_service_set_handle() failed with error code %d\n",nodeName.c_str(),serviceName.c_str(),ret);
			return false;
		}
	}else{
		fprintf(stderr, "[%s]-[%s]ERROR:ppService not nullptr,service is existed\n",nodeName.c_str(),serviceName.c_str());
		return false;
	}
	return true;
}

virtual int on_${name}(${name}_t& data) {
  fprintf(stderr, "ERROR: no virtual int on_${full_name}() handler overloaded for service ${name}!\n");
  return 1;
}

private:
  std::string m_nodeName;
  std::string m_serviceName;
  pService ppService;

};
${ns_closing}
#ifdef ${md_prefix_ns_define}
}
#endif
#endif