// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: params_service.proto
#ifndef GRPC_params_5fservice_2eproto__INCLUDED
#define GRPC_params_5fservice_2eproto__INCLUDED

#include "params_service.pb.h"

#include <functional>
#include <grpcpp/generic/async_generic_service.h>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/support/client_callback.h>
#include <grpcpp/client_context.h>
#include <grpcpp/completion_queue.h>
#include <grpcpp/support/message_allocator.h>
#include <grpcpp/support/method_handler.h>
#include <grpcpp/impl/proto_utils.h>
#include <grpcpp/impl/rpc_method.h>
#include <grpcpp/support/server_callback.h>
#include <grpcpp/impl/server_callback_handlers.h>
#include <grpcpp/server_context.h>
#include <grpcpp/impl/service_type.h>
#include <grpcpp/support/status.h>
#include <grpcpp/support/stub_options.h>
#include <grpcpp/support/sync_stream.h>
#include <grpcpp/ports_def.inc>

namespace controller {

class ParamsService final {
 public:
  static constexpr char const* service_full_name() {
    return "controller.ParamsService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // set rpc
    virtual ::grpc::Status SetJointSoftLimit(::grpc::ClientContext* context, const ::controller::SetJointParamsRequest& request, ::controller::SetParamResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::SetParamResponse>> AsyncSetJointSoftLimit(::grpc::ClientContext* context, const ::controller::SetJointParamsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::SetParamResponse>>(AsyncSetJointSoftLimitRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::SetParamResponse>> PrepareAsyncSetJointSoftLimit(::grpc::ClientContext* context, const ::controller::SetJointParamsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::SetParamResponse>>(PrepareAsyncSetJointSoftLimitRaw(context, request, cq));
    }
    virtual ::grpc::Status SetJointMaxVel(::grpc::ClientContext* context, const ::controller::SetJointParamsRequest& request, ::controller::SetParamResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::SetParamResponse>> AsyncSetJointMaxVel(::grpc::ClientContext* context, const ::controller::SetJointParamsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::SetParamResponse>>(AsyncSetJointMaxVelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::SetParamResponse>> PrepareAsyncSetJointMaxVel(::grpc::ClientContext* context, const ::controller::SetJointParamsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::SetParamResponse>>(PrepareAsyncSetJointMaxVelRaw(context, request, cq));
    }
    virtual ::grpc::Status SetJointMaxAcc(::grpc::ClientContext* context, const ::controller::SetJointParamsRequest& request, ::controller::SetParamResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::SetParamResponse>> AsyncSetJointMaxAcc(::grpc::ClientContext* context, const ::controller::SetJointParamsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::SetParamResponse>>(AsyncSetJointMaxAccRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::SetParamResponse>> PrepareAsyncSetJointMaxAcc(::grpc::ClientContext* context, const ::controller::SetJointParamsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::SetParamResponse>>(PrepareAsyncSetJointMaxAccRaw(context, request, cq));
    }
    virtual ::grpc::Status SetCartesianTranslationMaxVel(::grpc::ClientContext* context, const ::controller::SetCartesianParamsRequest& request, ::controller::SetParamResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::SetParamResponse>> AsyncSetCartesianTranslationMaxVel(::grpc::ClientContext* context, const ::controller::SetCartesianParamsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::SetParamResponse>>(AsyncSetCartesianTranslationMaxVelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::SetParamResponse>> PrepareAsyncSetCartesianTranslationMaxVel(::grpc::ClientContext* context, const ::controller::SetCartesianParamsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::SetParamResponse>>(PrepareAsyncSetCartesianTranslationMaxVelRaw(context, request, cq));
    }
    virtual ::grpc::Status SetCartesianTranslationMaxAcc(::grpc::ClientContext* context, const ::controller::SetCartesianParamsRequest& request, ::controller::SetParamResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::SetParamResponse>> AsyncSetCartesianTranslationMaxAcc(::grpc::ClientContext* context, const ::controller::SetCartesianParamsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::SetParamResponse>>(AsyncSetCartesianTranslationMaxAccRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::SetParamResponse>> PrepareAsyncSetCartesianTranslationMaxAcc(::grpc::ClientContext* context, const ::controller::SetCartesianParamsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::SetParamResponse>>(PrepareAsyncSetCartesianTranslationMaxAccRaw(context, request, cq));
    }
    virtual ::grpc::Status SetCartesianRotationMaxVel(::grpc::ClientContext* context, const ::controller::SetCartesianParamsRequest& request, ::controller::SetParamResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::SetParamResponse>> AsyncSetCartesianRotationMaxVel(::grpc::ClientContext* context, const ::controller::SetCartesianParamsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::SetParamResponse>>(AsyncSetCartesianRotationMaxVelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::SetParamResponse>> PrepareAsyncSetCartesianRotationMaxVel(::grpc::ClientContext* context, const ::controller::SetCartesianParamsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::SetParamResponse>>(PrepareAsyncSetCartesianRotationMaxVelRaw(context, request, cq));
    }
    virtual ::grpc::Status SetCartesianRotationMaxAcc(::grpc::ClientContext* context, const ::controller::SetCartesianParamsRequest& request, ::controller::SetParamResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::SetParamResponse>> AsyncSetCartesianRotationMaxAcc(::grpc::ClientContext* context, const ::controller::SetCartesianParamsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::SetParamResponse>>(AsyncSetCartesianRotationMaxAccRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::SetParamResponse>> PrepareAsyncSetCartesianRotationMaxAcc(::grpc::ClientContext* context, const ::controller::SetCartesianParamsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::SetParamResponse>>(PrepareAsyncSetCartesianRotationMaxAccRaw(context, request, cq));
    }
    virtual ::grpc::Status SetTcpOffset(::grpc::ClientContext* context, const ::controller::SetTcpOffsetParamsRequest& request, ::controller::SetParamResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::SetParamResponse>> AsyncSetTcpOffset(::grpc::ClientContext* context, const ::controller::SetTcpOffsetParamsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::SetParamResponse>>(AsyncSetTcpOffsetRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::SetParamResponse>> PrepareAsyncSetTcpOffset(::grpc::ClientContext* context, const ::controller::SetTcpOffsetParamsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::SetParamResponse>>(PrepareAsyncSetTcpOffsetRaw(context, request, cq));
    }
    virtual ::grpc::Status SetTcpPayload(::grpc::ClientContext* context, const ::controller::SetTcpPayloadParamsRequest& request, ::controller::SetParamResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::SetParamResponse>> AsyncSetTcpPayload(::grpc::ClientContext* context, const ::controller::SetTcpPayloadParamsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::SetParamResponse>>(AsyncSetTcpPayloadRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::SetParamResponse>> PrepareAsyncSetTcpPayload(::grpc::ClientContext* context, const ::controller::SetTcpPayloadParamsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::SetParamResponse>>(PrepareAsyncSetTcpPayloadRaw(context, request, cq));
    }
    // get rpc
    virtual ::grpc::Status GetJointSoftLimit(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::controller::GetJointParamsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetJointParamsResponse>> AsyncGetJointSoftLimit(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetJointParamsResponse>>(AsyncGetJointSoftLimitRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetJointParamsResponse>> PrepareAsyncGetJointSoftLimit(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetJointParamsResponse>>(PrepareAsyncGetJointSoftLimitRaw(context, request, cq));
    }
    virtual ::grpc::Status GetJointMaxVel(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::controller::GetJointParamsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetJointParamsResponse>> AsyncGetJointMaxVel(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetJointParamsResponse>>(AsyncGetJointMaxVelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetJointParamsResponse>> PrepareAsyncGetJointMaxVel(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetJointParamsResponse>>(PrepareAsyncGetJointMaxVelRaw(context, request, cq));
    }
    virtual ::grpc::Status GetJointMaxAcc(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::controller::GetJointParamsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetJointParamsResponse>> AsyncGetJointMaxAcc(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetJointParamsResponse>>(AsyncGetJointMaxAccRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetJointParamsResponse>> PrepareAsyncGetJointMaxAcc(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetJointParamsResponse>>(PrepareAsyncGetJointMaxAccRaw(context, request, cq));
    }
    virtual ::grpc::Status GetCartesianTranslationMaxVel(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::controller::GetCartesianParamsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetCartesianParamsResponse>> AsyncGetCartesianTranslationMaxVel(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetCartesianParamsResponse>>(AsyncGetCartesianTranslationMaxVelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetCartesianParamsResponse>> PrepareAsyncGetCartesianTranslationMaxVel(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetCartesianParamsResponse>>(PrepareAsyncGetCartesianTranslationMaxVelRaw(context, request, cq));
    }
    virtual ::grpc::Status GetCartesianTranslationMaxAcc(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::controller::GetCartesianParamsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetCartesianParamsResponse>> AsyncGetCartesianTranslationMaxAcc(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetCartesianParamsResponse>>(AsyncGetCartesianTranslationMaxAccRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetCartesianParamsResponse>> PrepareAsyncGetCartesianTranslationMaxAcc(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetCartesianParamsResponse>>(PrepareAsyncGetCartesianTranslationMaxAccRaw(context, request, cq));
    }
    virtual ::grpc::Status GetCartesianRotationMaxVel(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::controller::GetCartesianParamsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetCartesianParamsResponse>> AsyncGetCartesianRotationMaxVel(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetCartesianParamsResponse>>(AsyncGetCartesianRotationMaxVelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetCartesianParamsResponse>> PrepareAsyncGetCartesianRotationMaxVel(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetCartesianParamsResponse>>(PrepareAsyncGetCartesianRotationMaxVelRaw(context, request, cq));
    }
    virtual ::grpc::Status GetCartesianRotationMaxAcc(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::controller::GetCartesianParamsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetCartesianParamsResponse>> AsyncGetCartesianRotationMaxAcc(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetCartesianParamsResponse>>(AsyncGetCartesianRotationMaxAccRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetCartesianParamsResponse>> PrepareAsyncGetCartesianRotationMaxAcc(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetCartesianParamsResponse>>(PrepareAsyncGetCartesianRotationMaxAccRaw(context, request, cq));
    }
    virtual ::grpc::Status GetTcpOffset(::grpc::ClientContext* context, const ::controller::GetTcpOffsetRequest& request, ::controller::GetTcpOffsetResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetTcpOffsetResponse>> AsyncGetTcpOffset(::grpc::ClientContext* context, const ::controller::GetTcpOffsetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetTcpOffsetResponse>>(AsyncGetTcpOffsetRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetTcpOffsetResponse>> PrepareAsyncGetTcpOffset(::grpc::ClientContext* context, const ::controller::GetTcpOffsetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetTcpOffsetResponse>>(PrepareAsyncGetTcpOffsetRaw(context, request, cq));
    }
    virtual ::grpc::Status GetTcpPayload(::grpc::ClientContext* context, const ::controller::GetTcpPayloadRequest& request, ::controller::GetTcpPayloadResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetTcpPayloadResponse>> AsyncGetTcpPayload(::grpc::ClientContext* context, const ::controller::GetTcpPayloadRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetTcpPayloadResponse>>(AsyncGetTcpPayloadRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetTcpPayloadResponse>> PrepareAsyncGetTcpPayload(::grpc::ClientContext* context, const ::controller::GetTcpPayloadRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetTcpPayloadResponse>>(PrepareAsyncGetTcpPayloadRaw(context, request, cq));
    }
    virtual ::grpc::Status ForwardKinematics(::grpc::ClientContext* context, const ::controller::ForwardKinematicsRequest& request, ::controller::ForwardKinematicsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::ForwardKinematicsResponse>> AsyncForwardKinematics(::grpc::ClientContext* context, const ::controller::ForwardKinematicsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::ForwardKinematicsResponse>>(AsyncForwardKinematicsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::ForwardKinematicsResponse>> PrepareAsyncForwardKinematics(::grpc::ClientContext* context, const ::controller::ForwardKinematicsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::ForwardKinematicsResponse>>(PrepareAsyncForwardKinematicsRaw(context, request, cq));
    }
    virtual ::grpc::Status InverseKinematics(::grpc::ClientContext* context, const ::controller::InverseKinematicsRequest& request, ::controller::InverseKinematicsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::InverseKinematicsResponse>> AsyncInverseKinematics(::grpc::ClientContext* context, const ::controller::InverseKinematicsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::InverseKinematicsResponse>>(AsyncInverseKinematicsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::InverseKinematicsResponse>> PrepareAsyncInverseKinematics(::grpc::ClientContext* context, const ::controller::InverseKinematicsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::InverseKinematicsResponse>>(PrepareAsyncInverseKinematicsRaw(context, request, cq));
    }
    // get mechanical
    virtual ::grpc::Status GetJointMechanicalLimit(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::controller::GetJointParamsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetJointParamsResponse>> AsyncGetJointMechanicalLimit(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetJointParamsResponse>>(AsyncGetJointMechanicalLimitRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetJointParamsResponse>> PrepareAsyncGetJointMechanicalLimit(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetJointParamsResponse>>(PrepareAsyncGetJointMechanicalLimitRaw(context, request, cq));
    }
    virtual ::grpc::Status GetJointMechanicalMaxVel(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::controller::GetJointParamsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetJointParamsResponse>> AsyncGetJointMechanicalMaxVel(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetJointParamsResponse>>(AsyncGetJointMechanicalMaxVelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetJointParamsResponse>> PrepareAsyncGetJointMechanicalMaxVel(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetJointParamsResponse>>(PrepareAsyncGetJointMechanicalMaxVelRaw(context, request, cq));
    }
    virtual ::grpc::Status GetJointMechanicalMaxAcc(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::controller::GetJointParamsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetJointParamsResponse>> AsyncGetJointMechanicalMaxAcc(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetJointParamsResponse>>(AsyncGetJointMechanicalMaxAccRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetJointParamsResponse>> PrepareAsyncGetJointMechanicalMaxAcc(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetJointParamsResponse>>(PrepareAsyncGetJointMechanicalMaxAccRaw(context, request, cq));
    }
    virtual ::grpc::Status GetCartesianMechanicalTranslationMaxVel(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::controller::GetCartesianParamsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetCartesianParamsResponse>> AsyncGetCartesianMechanicalTranslationMaxVel(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetCartesianParamsResponse>>(AsyncGetCartesianMechanicalTranslationMaxVelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetCartesianParamsResponse>> PrepareAsyncGetCartesianMechanicalTranslationMaxVel(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetCartesianParamsResponse>>(PrepareAsyncGetCartesianMechanicalTranslationMaxVelRaw(context, request, cq));
    }
    virtual ::grpc::Status GetCartesianMechanicalTranslationMaxAcc(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::controller::GetCartesianParamsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetCartesianParamsResponse>> AsyncGetCartesianMechanicalTranslationMaxAcc(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetCartesianParamsResponse>>(AsyncGetCartesianMechanicalTranslationMaxAccRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetCartesianParamsResponse>> PrepareAsyncGetCartesianMechanicalTranslationMaxAcc(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetCartesianParamsResponse>>(PrepareAsyncGetCartesianMechanicalTranslationMaxAccRaw(context, request, cq));
    }
    virtual ::grpc::Status GetCartesianMechanicalRotationMaxVel(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::controller::GetCartesianParamsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetCartesianParamsResponse>> AsyncGetCartesianMechanicalRotationMaxVel(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetCartesianParamsResponse>>(AsyncGetCartesianMechanicalRotationMaxVelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetCartesianParamsResponse>> PrepareAsyncGetCartesianMechanicalRotationMaxVel(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetCartesianParamsResponse>>(PrepareAsyncGetCartesianMechanicalRotationMaxVelRaw(context, request, cq));
    }
    virtual ::grpc::Status GetCartesianMechanicalRotationMaxAcc(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::controller::GetCartesianParamsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetCartesianParamsResponse>> AsyncGetCartesianMechanicalRotationMaxAcc(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetCartesianParamsResponse>>(AsyncGetCartesianMechanicalRotationMaxAccRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetCartesianParamsResponse>> PrepareAsyncGetCartesianMechanicalRotationMaxAcc(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetCartesianParamsResponse>>(PrepareAsyncGetCartesianMechanicalRotationMaxAccRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      // set rpc
      virtual void SetJointSoftLimit(::grpc::ClientContext* context, const ::controller::SetJointParamsRequest* request, ::controller::SetParamResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetJointSoftLimit(::grpc::ClientContext* context, const ::controller::SetJointParamsRequest* request, ::controller::SetParamResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetJointMaxVel(::grpc::ClientContext* context, const ::controller::SetJointParamsRequest* request, ::controller::SetParamResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetJointMaxVel(::grpc::ClientContext* context, const ::controller::SetJointParamsRequest* request, ::controller::SetParamResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetJointMaxAcc(::grpc::ClientContext* context, const ::controller::SetJointParamsRequest* request, ::controller::SetParamResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetJointMaxAcc(::grpc::ClientContext* context, const ::controller::SetJointParamsRequest* request, ::controller::SetParamResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetCartesianTranslationMaxVel(::grpc::ClientContext* context, const ::controller::SetCartesianParamsRequest* request, ::controller::SetParamResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetCartesianTranslationMaxVel(::grpc::ClientContext* context, const ::controller::SetCartesianParamsRequest* request, ::controller::SetParamResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetCartesianTranslationMaxAcc(::grpc::ClientContext* context, const ::controller::SetCartesianParamsRequest* request, ::controller::SetParamResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetCartesianTranslationMaxAcc(::grpc::ClientContext* context, const ::controller::SetCartesianParamsRequest* request, ::controller::SetParamResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetCartesianRotationMaxVel(::grpc::ClientContext* context, const ::controller::SetCartesianParamsRequest* request, ::controller::SetParamResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetCartesianRotationMaxVel(::grpc::ClientContext* context, const ::controller::SetCartesianParamsRequest* request, ::controller::SetParamResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetCartesianRotationMaxAcc(::grpc::ClientContext* context, const ::controller::SetCartesianParamsRequest* request, ::controller::SetParamResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetCartesianRotationMaxAcc(::grpc::ClientContext* context, const ::controller::SetCartesianParamsRequest* request, ::controller::SetParamResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetTcpOffset(::grpc::ClientContext* context, const ::controller::SetTcpOffsetParamsRequest* request, ::controller::SetParamResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetTcpOffset(::grpc::ClientContext* context, const ::controller::SetTcpOffsetParamsRequest* request, ::controller::SetParamResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetTcpPayload(::grpc::ClientContext* context, const ::controller::SetTcpPayloadParamsRequest* request, ::controller::SetParamResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetTcpPayload(::grpc::ClientContext* context, const ::controller::SetTcpPayloadParamsRequest* request, ::controller::SetParamResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // get rpc
      virtual void GetJointSoftLimit(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::controller::GetJointParamsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetJointSoftLimit(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::controller::GetJointParamsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetJointMaxVel(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::controller::GetJointParamsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetJointMaxVel(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::controller::GetJointParamsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetJointMaxAcc(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::controller::GetJointParamsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetJointMaxAcc(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::controller::GetJointParamsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetCartesianTranslationMaxVel(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::controller::GetCartesianParamsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetCartesianTranslationMaxVel(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::controller::GetCartesianParamsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetCartesianTranslationMaxAcc(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::controller::GetCartesianParamsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetCartesianTranslationMaxAcc(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::controller::GetCartesianParamsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetCartesianRotationMaxVel(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::controller::GetCartesianParamsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetCartesianRotationMaxVel(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::controller::GetCartesianParamsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetCartesianRotationMaxAcc(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::controller::GetCartesianParamsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetCartesianRotationMaxAcc(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::controller::GetCartesianParamsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetTcpOffset(::grpc::ClientContext* context, const ::controller::GetTcpOffsetRequest* request, ::controller::GetTcpOffsetResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetTcpOffset(::grpc::ClientContext* context, const ::controller::GetTcpOffsetRequest* request, ::controller::GetTcpOffsetResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetTcpPayload(::grpc::ClientContext* context, const ::controller::GetTcpPayloadRequest* request, ::controller::GetTcpPayloadResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetTcpPayload(::grpc::ClientContext* context, const ::controller::GetTcpPayloadRequest* request, ::controller::GetTcpPayloadResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void ForwardKinematics(::grpc::ClientContext* context, const ::controller::ForwardKinematicsRequest* request, ::controller::ForwardKinematicsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ForwardKinematics(::grpc::ClientContext* context, const ::controller::ForwardKinematicsRequest* request, ::controller::ForwardKinematicsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void InverseKinematics(::grpc::ClientContext* context, const ::controller::InverseKinematicsRequest* request, ::controller::InverseKinematicsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void InverseKinematics(::grpc::ClientContext* context, const ::controller::InverseKinematicsRequest* request, ::controller::InverseKinematicsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // get mechanical
      virtual void GetJointMechanicalLimit(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::controller::GetJointParamsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetJointMechanicalLimit(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::controller::GetJointParamsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetJointMechanicalMaxVel(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::controller::GetJointParamsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetJointMechanicalMaxVel(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::controller::GetJointParamsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetJointMechanicalMaxAcc(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::controller::GetJointParamsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetJointMechanicalMaxAcc(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::controller::GetJointParamsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetCartesianMechanicalTranslationMaxVel(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::controller::GetCartesianParamsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetCartesianMechanicalTranslationMaxVel(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::controller::GetCartesianParamsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetCartesianMechanicalTranslationMaxAcc(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::controller::GetCartesianParamsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetCartesianMechanicalTranslationMaxAcc(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::controller::GetCartesianParamsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetCartesianMechanicalRotationMaxVel(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::controller::GetCartesianParamsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetCartesianMechanicalRotationMaxVel(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::controller::GetCartesianParamsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetCartesianMechanicalRotationMaxAcc(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::controller::GetCartesianParamsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetCartesianMechanicalRotationMaxAcc(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::controller::GetCartesianParamsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::controller::SetParamResponse>* AsyncSetJointSoftLimitRaw(::grpc::ClientContext* context, const ::controller::SetJointParamsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::controller::SetParamResponse>* PrepareAsyncSetJointSoftLimitRaw(::grpc::ClientContext* context, const ::controller::SetJointParamsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::controller::SetParamResponse>* AsyncSetJointMaxVelRaw(::grpc::ClientContext* context, const ::controller::SetJointParamsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::controller::SetParamResponse>* PrepareAsyncSetJointMaxVelRaw(::grpc::ClientContext* context, const ::controller::SetJointParamsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::controller::SetParamResponse>* AsyncSetJointMaxAccRaw(::grpc::ClientContext* context, const ::controller::SetJointParamsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::controller::SetParamResponse>* PrepareAsyncSetJointMaxAccRaw(::grpc::ClientContext* context, const ::controller::SetJointParamsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::controller::SetParamResponse>* AsyncSetCartesianTranslationMaxVelRaw(::grpc::ClientContext* context, const ::controller::SetCartesianParamsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::controller::SetParamResponse>* PrepareAsyncSetCartesianTranslationMaxVelRaw(::grpc::ClientContext* context, const ::controller::SetCartesianParamsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::controller::SetParamResponse>* AsyncSetCartesianTranslationMaxAccRaw(::grpc::ClientContext* context, const ::controller::SetCartesianParamsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::controller::SetParamResponse>* PrepareAsyncSetCartesianTranslationMaxAccRaw(::grpc::ClientContext* context, const ::controller::SetCartesianParamsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::controller::SetParamResponse>* AsyncSetCartesianRotationMaxVelRaw(::grpc::ClientContext* context, const ::controller::SetCartesianParamsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::controller::SetParamResponse>* PrepareAsyncSetCartesianRotationMaxVelRaw(::grpc::ClientContext* context, const ::controller::SetCartesianParamsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::controller::SetParamResponse>* AsyncSetCartesianRotationMaxAccRaw(::grpc::ClientContext* context, const ::controller::SetCartesianParamsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::controller::SetParamResponse>* PrepareAsyncSetCartesianRotationMaxAccRaw(::grpc::ClientContext* context, const ::controller::SetCartesianParamsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::controller::SetParamResponse>* AsyncSetTcpOffsetRaw(::grpc::ClientContext* context, const ::controller::SetTcpOffsetParamsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::controller::SetParamResponse>* PrepareAsyncSetTcpOffsetRaw(::grpc::ClientContext* context, const ::controller::SetTcpOffsetParamsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::controller::SetParamResponse>* AsyncSetTcpPayloadRaw(::grpc::ClientContext* context, const ::controller::SetTcpPayloadParamsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::controller::SetParamResponse>* PrepareAsyncSetTcpPayloadRaw(::grpc::ClientContext* context, const ::controller::SetTcpPayloadParamsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetJointParamsResponse>* AsyncGetJointSoftLimitRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetJointParamsResponse>* PrepareAsyncGetJointSoftLimitRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetJointParamsResponse>* AsyncGetJointMaxVelRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetJointParamsResponse>* PrepareAsyncGetJointMaxVelRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetJointParamsResponse>* AsyncGetJointMaxAccRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetJointParamsResponse>* PrepareAsyncGetJointMaxAccRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetCartesianParamsResponse>* AsyncGetCartesianTranslationMaxVelRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetCartesianParamsResponse>* PrepareAsyncGetCartesianTranslationMaxVelRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetCartesianParamsResponse>* AsyncGetCartesianTranslationMaxAccRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetCartesianParamsResponse>* PrepareAsyncGetCartesianTranslationMaxAccRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetCartesianParamsResponse>* AsyncGetCartesianRotationMaxVelRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetCartesianParamsResponse>* PrepareAsyncGetCartesianRotationMaxVelRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetCartesianParamsResponse>* AsyncGetCartesianRotationMaxAccRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetCartesianParamsResponse>* PrepareAsyncGetCartesianRotationMaxAccRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetTcpOffsetResponse>* AsyncGetTcpOffsetRaw(::grpc::ClientContext* context, const ::controller::GetTcpOffsetRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetTcpOffsetResponse>* PrepareAsyncGetTcpOffsetRaw(::grpc::ClientContext* context, const ::controller::GetTcpOffsetRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetTcpPayloadResponse>* AsyncGetTcpPayloadRaw(::grpc::ClientContext* context, const ::controller::GetTcpPayloadRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetTcpPayloadResponse>* PrepareAsyncGetTcpPayloadRaw(::grpc::ClientContext* context, const ::controller::GetTcpPayloadRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::controller::ForwardKinematicsResponse>* AsyncForwardKinematicsRaw(::grpc::ClientContext* context, const ::controller::ForwardKinematicsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::controller::ForwardKinematicsResponse>* PrepareAsyncForwardKinematicsRaw(::grpc::ClientContext* context, const ::controller::ForwardKinematicsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::controller::InverseKinematicsResponse>* AsyncInverseKinematicsRaw(::grpc::ClientContext* context, const ::controller::InverseKinematicsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::controller::InverseKinematicsResponse>* PrepareAsyncInverseKinematicsRaw(::grpc::ClientContext* context, const ::controller::InverseKinematicsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetJointParamsResponse>* AsyncGetJointMechanicalLimitRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetJointParamsResponse>* PrepareAsyncGetJointMechanicalLimitRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetJointParamsResponse>* AsyncGetJointMechanicalMaxVelRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetJointParamsResponse>* PrepareAsyncGetJointMechanicalMaxVelRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetJointParamsResponse>* AsyncGetJointMechanicalMaxAccRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetJointParamsResponse>* PrepareAsyncGetJointMechanicalMaxAccRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetCartesianParamsResponse>* AsyncGetCartesianMechanicalTranslationMaxVelRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetCartesianParamsResponse>* PrepareAsyncGetCartesianMechanicalTranslationMaxVelRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetCartesianParamsResponse>* AsyncGetCartesianMechanicalTranslationMaxAccRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetCartesianParamsResponse>* PrepareAsyncGetCartesianMechanicalTranslationMaxAccRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetCartesianParamsResponse>* AsyncGetCartesianMechanicalRotationMaxVelRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetCartesianParamsResponse>* PrepareAsyncGetCartesianMechanicalRotationMaxVelRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetCartesianParamsResponse>* AsyncGetCartesianMechanicalRotationMaxAccRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::controller::GetCartesianParamsResponse>* PrepareAsyncGetCartesianMechanicalRotationMaxAccRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status SetJointSoftLimit(::grpc::ClientContext* context, const ::controller::SetJointParamsRequest& request, ::controller::SetParamResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::SetParamResponse>> AsyncSetJointSoftLimit(::grpc::ClientContext* context, const ::controller::SetJointParamsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::SetParamResponse>>(AsyncSetJointSoftLimitRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::SetParamResponse>> PrepareAsyncSetJointSoftLimit(::grpc::ClientContext* context, const ::controller::SetJointParamsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::SetParamResponse>>(PrepareAsyncSetJointSoftLimitRaw(context, request, cq));
    }
    ::grpc::Status SetJointMaxVel(::grpc::ClientContext* context, const ::controller::SetJointParamsRequest& request, ::controller::SetParamResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::SetParamResponse>> AsyncSetJointMaxVel(::grpc::ClientContext* context, const ::controller::SetJointParamsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::SetParamResponse>>(AsyncSetJointMaxVelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::SetParamResponse>> PrepareAsyncSetJointMaxVel(::grpc::ClientContext* context, const ::controller::SetJointParamsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::SetParamResponse>>(PrepareAsyncSetJointMaxVelRaw(context, request, cq));
    }
    ::grpc::Status SetJointMaxAcc(::grpc::ClientContext* context, const ::controller::SetJointParamsRequest& request, ::controller::SetParamResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::SetParamResponse>> AsyncSetJointMaxAcc(::grpc::ClientContext* context, const ::controller::SetJointParamsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::SetParamResponse>>(AsyncSetJointMaxAccRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::SetParamResponse>> PrepareAsyncSetJointMaxAcc(::grpc::ClientContext* context, const ::controller::SetJointParamsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::SetParamResponse>>(PrepareAsyncSetJointMaxAccRaw(context, request, cq));
    }
    ::grpc::Status SetCartesianTranslationMaxVel(::grpc::ClientContext* context, const ::controller::SetCartesianParamsRequest& request, ::controller::SetParamResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::SetParamResponse>> AsyncSetCartesianTranslationMaxVel(::grpc::ClientContext* context, const ::controller::SetCartesianParamsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::SetParamResponse>>(AsyncSetCartesianTranslationMaxVelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::SetParamResponse>> PrepareAsyncSetCartesianTranslationMaxVel(::grpc::ClientContext* context, const ::controller::SetCartesianParamsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::SetParamResponse>>(PrepareAsyncSetCartesianTranslationMaxVelRaw(context, request, cq));
    }
    ::grpc::Status SetCartesianTranslationMaxAcc(::grpc::ClientContext* context, const ::controller::SetCartesianParamsRequest& request, ::controller::SetParamResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::SetParamResponse>> AsyncSetCartesianTranslationMaxAcc(::grpc::ClientContext* context, const ::controller::SetCartesianParamsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::SetParamResponse>>(AsyncSetCartesianTranslationMaxAccRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::SetParamResponse>> PrepareAsyncSetCartesianTranslationMaxAcc(::grpc::ClientContext* context, const ::controller::SetCartesianParamsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::SetParamResponse>>(PrepareAsyncSetCartesianTranslationMaxAccRaw(context, request, cq));
    }
    ::grpc::Status SetCartesianRotationMaxVel(::grpc::ClientContext* context, const ::controller::SetCartesianParamsRequest& request, ::controller::SetParamResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::SetParamResponse>> AsyncSetCartesianRotationMaxVel(::grpc::ClientContext* context, const ::controller::SetCartesianParamsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::SetParamResponse>>(AsyncSetCartesianRotationMaxVelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::SetParamResponse>> PrepareAsyncSetCartesianRotationMaxVel(::grpc::ClientContext* context, const ::controller::SetCartesianParamsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::SetParamResponse>>(PrepareAsyncSetCartesianRotationMaxVelRaw(context, request, cq));
    }
    ::grpc::Status SetCartesianRotationMaxAcc(::grpc::ClientContext* context, const ::controller::SetCartesianParamsRequest& request, ::controller::SetParamResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::SetParamResponse>> AsyncSetCartesianRotationMaxAcc(::grpc::ClientContext* context, const ::controller::SetCartesianParamsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::SetParamResponse>>(AsyncSetCartesianRotationMaxAccRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::SetParamResponse>> PrepareAsyncSetCartesianRotationMaxAcc(::grpc::ClientContext* context, const ::controller::SetCartesianParamsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::SetParamResponse>>(PrepareAsyncSetCartesianRotationMaxAccRaw(context, request, cq));
    }
    ::grpc::Status SetTcpOffset(::grpc::ClientContext* context, const ::controller::SetTcpOffsetParamsRequest& request, ::controller::SetParamResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::SetParamResponse>> AsyncSetTcpOffset(::grpc::ClientContext* context, const ::controller::SetTcpOffsetParamsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::SetParamResponse>>(AsyncSetTcpOffsetRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::SetParamResponse>> PrepareAsyncSetTcpOffset(::grpc::ClientContext* context, const ::controller::SetTcpOffsetParamsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::SetParamResponse>>(PrepareAsyncSetTcpOffsetRaw(context, request, cq));
    }
    ::grpc::Status SetTcpPayload(::grpc::ClientContext* context, const ::controller::SetTcpPayloadParamsRequest& request, ::controller::SetParamResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::SetParamResponse>> AsyncSetTcpPayload(::grpc::ClientContext* context, const ::controller::SetTcpPayloadParamsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::SetParamResponse>>(AsyncSetTcpPayloadRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::SetParamResponse>> PrepareAsyncSetTcpPayload(::grpc::ClientContext* context, const ::controller::SetTcpPayloadParamsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::SetParamResponse>>(PrepareAsyncSetTcpPayloadRaw(context, request, cq));
    }
    ::grpc::Status GetJointSoftLimit(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::controller::GetJointParamsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::GetJointParamsResponse>> AsyncGetJointSoftLimit(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::GetJointParamsResponse>>(AsyncGetJointSoftLimitRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::GetJointParamsResponse>> PrepareAsyncGetJointSoftLimit(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::GetJointParamsResponse>>(PrepareAsyncGetJointSoftLimitRaw(context, request, cq));
    }
    ::grpc::Status GetJointMaxVel(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::controller::GetJointParamsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::GetJointParamsResponse>> AsyncGetJointMaxVel(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::GetJointParamsResponse>>(AsyncGetJointMaxVelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::GetJointParamsResponse>> PrepareAsyncGetJointMaxVel(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::GetJointParamsResponse>>(PrepareAsyncGetJointMaxVelRaw(context, request, cq));
    }
    ::grpc::Status GetJointMaxAcc(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::controller::GetJointParamsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::GetJointParamsResponse>> AsyncGetJointMaxAcc(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::GetJointParamsResponse>>(AsyncGetJointMaxAccRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::GetJointParamsResponse>> PrepareAsyncGetJointMaxAcc(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::GetJointParamsResponse>>(PrepareAsyncGetJointMaxAccRaw(context, request, cq));
    }
    ::grpc::Status GetCartesianTranslationMaxVel(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::controller::GetCartesianParamsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::GetCartesianParamsResponse>> AsyncGetCartesianTranslationMaxVel(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::GetCartesianParamsResponse>>(AsyncGetCartesianTranslationMaxVelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::GetCartesianParamsResponse>> PrepareAsyncGetCartesianTranslationMaxVel(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::GetCartesianParamsResponse>>(PrepareAsyncGetCartesianTranslationMaxVelRaw(context, request, cq));
    }
    ::grpc::Status GetCartesianTranslationMaxAcc(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::controller::GetCartesianParamsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::GetCartesianParamsResponse>> AsyncGetCartesianTranslationMaxAcc(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::GetCartesianParamsResponse>>(AsyncGetCartesianTranslationMaxAccRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::GetCartesianParamsResponse>> PrepareAsyncGetCartesianTranslationMaxAcc(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::GetCartesianParamsResponse>>(PrepareAsyncGetCartesianTranslationMaxAccRaw(context, request, cq));
    }
    ::grpc::Status GetCartesianRotationMaxVel(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::controller::GetCartesianParamsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::GetCartesianParamsResponse>> AsyncGetCartesianRotationMaxVel(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::GetCartesianParamsResponse>>(AsyncGetCartesianRotationMaxVelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::GetCartesianParamsResponse>> PrepareAsyncGetCartesianRotationMaxVel(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::GetCartesianParamsResponse>>(PrepareAsyncGetCartesianRotationMaxVelRaw(context, request, cq));
    }
    ::grpc::Status GetCartesianRotationMaxAcc(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::controller::GetCartesianParamsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::GetCartesianParamsResponse>> AsyncGetCartesianRotationMaxAcc(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::GetCartesianParamsResponse>>(AsyncGetCartesianRotationMaxAccRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::GetCartesianParamsResponse>> PrepareAsyncGetCartesianRotationMaxAcc(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::GetCartesianParamsResponse>>(PrepareAsyncGetCartesianRotationMaxAccRaw(context, request, cq));
    }
    ::grpc::Status GetTcpOffset(::grpc::ClientContext* context, const ::controller::GetTcpOffsetRequest& request, ::controller::GetTcpOffsetResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::GetTcpOffsetResponse>> AsyncGetTcpOffset(::grpc::ClientContext* context, const ::controller::GetTcpOffsetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::GetTcpOffsetResponse>>(AsyncGetTcpOffsetRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::GetTcpOffsetResponse>> PrepareAsyncGetTcpOffset(::grpc::ClientContext* context, const ::controller::GetTcpOffsetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::GetTcpOffsetResponse>>(PrepareAsyncGetTcpOffsetRaw(context, request, cq));
    }
    ::grpc::Status GetTcpPayload(::grpc::ClientContext* context, const ::controller::GetTcpPayloadRequest& request, ::controller::GetTcpPayloadResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::GetTcpPayloadResponse>> AsyncGetTcpPayload(::grpc::ClientContext* context, const ::controller::GetTcpPayloadRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::GetTcpPayloadResponse>>(AsyncGetTcpPayloadRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::GetTcpPayloadResponse>> PrepareAsyncGetTcpPayload(::grpc::ClientContext* context, const ::controller::GetTcpPayloadRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::GetTcpPayloadResponse>>(PrepareAsyncGetTcpPayloadRaw(context, request, cq));
    }
    ::grpc::Status ForwardKinematics(::grpc::ClientContext* context, const ::controller::ForwardKinematicsRequest& request, ::controller::ForwardKinematicsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::ForwardKinematicsResponse>> AsyncForwardKinematics(::grpc::ClientContext* context, const ::controller::ForwardKinematicsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::ForwardKinematicsResponse>>(AsyncForwardKinematicsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::ForwardKinematicsResponse>> PrepareAsyncForwardKinematics(::grpc::ClientContext* context, const ::controller::ForwardKinematicsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::ForwardKinematicsResponse>>(PrepareAsyncForwardKinematicsRaw(context, request, cq));
    }
    ::grpc::Status InverseKinematics(::grpc::ClientContext* context, const ::controller::InverseKinematicsRequest& request, ::controller::InverseKinematicsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::InverseKinematicsResponse>> AsyncInverseKinematics(::grpc::ClientContext* context, const ::controller::InverseKinematicsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::InverseKinematicsResponse>>(AsyncInverseKinematicsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::InverseKinematicsResponse>> PrepareAsyncInverseKinematics(::grpc::ClientContext* context, const ::controller::InverseKinematicsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::InverseKinematicsResponse>>(PrepareAsyncInverseKinematicsRaw(context, request, cq));
    }
    ::grpc::Status GetJointMechanicalLimit(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::controller::GetJointParamsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::GetJointParamsResponse>> AsyncGetJointMechanicalLimit(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::GetJointParamsResponse>>(AsyncGetJointMechanicalLimitRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::GetJointParamsResponse>> PrepareAsyncGetJointMechanicalLimit(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::GetJointParamsResponse>>(PrepareAsyncGetJointMechanicalLimitRaw(context, request, cq));
    }
    ::grpc::Status GetJointMechanicalMaxVel(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::controller::GetJointParamsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::GetJointParamsResponse>> AsyncGetJointMechanicalMaxVel(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::GetJointParamsResponse>>(AsyncGetJointMechanicalMaxVelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::GetJointParamsResponse>> PrepareAsyncGetJointMechanicalMaxVel(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::GetJointParamsResponse>>(PrepareAsyncGetJointMechanicalMaxVelRaw(context, request, cq));
    }
    ::grpc::Status GetJointMechanicalMaxAcc(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::controller::GetJointParamsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::GetJointParamsResponse>> AsyncGetJointMechanicalMaxAcc(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::GetJointParamsResponse>>(AsyncGetJointMechanicalMaxAccRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::GetJointParamsResponse>> PrepareAsyncGetJointMechanicalMaxAcc(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::GetJointParamsResponse>>(PrepareAsyncGetJointMechanicalMaxAccRaw(context, request, cq));
    }
    ::grpc::Status GetCartesianMechanicalTranslationMaxVel(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::controller::GetCartesianParamsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::GetCartesianParamsResponse>> AsyncGetCartesianMechanicalTranslationMaxVel(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::GetCartesianParamsResponse>>(AsyncGetCartesianMechanicalTranslationMaxVelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::GetCartesianParamsResponse>> PrepareAsyncGetCartesianMechanicalTranslationMaxVel(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::GetCartesianParamsResponse>>(PrepareAsyncGetCartesianMechanicalTranslationMaxVelRaw(context, request, cq));
    }
    ::grpc::Status GetCartesianMechanicalTranslationMaxAcc(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::controller::GetCartesianParamsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::GetCartesianParamsResponse>> AsyncGetCartesianMechanicalTranslationMaxAcc(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::GetCartesianParamsResponse>>(AsyncGetCartesianMechanicalTranslationMaxAccRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::GetCartesianParamsResponse>> PrepareAsyncGetCartesianMechanicalTranslationMaxAcc(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::GetCartesianParamsResponse>>(PrepareAsyncGetCartesianMechanicalTranslationMaxAccRaw(context, request, cq));
    }
    ::grpc::Status GetCartesianMechanicalRotationMaxVel(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::controller::GetCartesianParamsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::GetCartesianParamsResponse>> AsyncGetCartesianMechanicalRotationMaxVel(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::GetCartesianParamsResponse>>(AsyncGetCartesianMechanicalRotationMaxVelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::GetCartesianParamsResponse>> PrepareAsyncGetCartesianMechanicalRotationMaxVel(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::GetCartesianParamsResponse>>(PrepareAsyncGetCartesianMechanicalRotationMaxVelRaw(context, request, cq));
    }
    ::grpc::Status GetCartesianMechanicalRotationMaxAcc(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::controller::GetCartesianParamsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::GetCartesianParamsResponse>> AsyncGetCartesianMechanicalRotationMaxAcc(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::GetCartesianParamsResponse>>(AsyncGetCartesianMechanicalRotationMaxAccRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::GetCartesianParamsResponse>> PrepareAsyncGetCartesianMechanicalRotationMaxAcc(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::controller::GetCartesianParamsResponse>>(PrepareAsyncGetCartesianMechanicalRotationMaxAccRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void SetJointSoftLimit(::grpc::ClientContext* context, const ::controller::SetJointParamsRequest* request, ::controller::SetParamResponse* response, std::function<void(::grpc::Status)>) override;
      void SetJointSoftLimit(::grpc::ClientContext* context, const ::controller::SetJointParamsRequest* request, ::controller::SetParamResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetJointMaxVel(::grpc::ClientContext* context, const ::controller::SetJointParamsRequest* request, ::controller::SetParamResponse* response, std::function<void(::grpc::Status)>) override;
      void SetJointMaxVel(::grpc::ClientContext* context, const ::controller::SetJointParamsRequest* request, ::controller::SetParamResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetJointMaxAcc(::grpc::ClientContext* context, const ::controller::SetJointParamsRequest* request, ::controller::SetParamResponse* response, std::function<void(::grpc::Status)>) override;
      void SetJointMaxAcc(::grpc::ClientContext* context, const ::controller::SetJointParamsRequest* request, ::controller::SetParamResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetCartesianTranslationMaxVel(::grpc::ClientContext* context, const ::controller::SetCartesianParamsRequest* request, ::controller::SetParamResponse* response, std::function<void(::grpc::Status)>) override;
      void SetCartesianTranslationMaxVel(::grpc::ClientContext* context, const ::controller::SetCartesianParamsRequest* request, ::controller::SetParamResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetCartesianTranslationMaxAcc(::grpc::ClientContext* context, const ::controller::SetCartesianParamsRequest* request, ::controller::SetParamResponse* response, std::function<void(::grpc::Status)>) override;
      void SetCartesianTranslationMaxAcc(::grpc::ClientContext* context, const ::controller::SetCartesianParamsRequest* request, ::controller::SetParamResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetCartesianRotationMaxVel(::grpc::ClientContext* context, const ::controller::SetCartesianParamsRequest* request, ::controller::SetParamResponse* response, std::function<void(::grpc::Status)>) override;
      void SetCartesianRotationMaxVel(::grpc::ClientContext* context, const ::controller::SetCartesianParamsRequest* request, ::controller::SetParamResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetCartesianRotationMaxAcc(::grpc::ClientContext* context, const ::controller::SetCartesianParamsRequest* request, ::controller::SetParamResponse* response, std::function<void(::grpc::Status)>) override;
      void SetCartesianRotationMaxAcc(::grpc::ClientContext* context, const ::controller::SetCartesianParamsRequest* request, ::controller::SetParamResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetTcpOffset(::grpc::ClientContext* context, const ::controller::SetTcpOffsetParamsRequest* request, ::controller::SetParamResponse* response, std::function<void(::grpc::Status)>) override;
      void SetTcpOffset(::grpc::ClientContext* context, const ::controller::SetTcpOffsetParamsRequest* request, ::controller::SetParamResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetTcpPayload(::grpc::ClientContext* context, const ::controller::SetTcpPayloadParamsRequest* request, ::controller::SetParamResponse* response, std::function<void(::grpc::Status)>) override;
      void SetTcpPayload(::grpc::ClientContext* context, const ::controller::SetTcpPayloadParamsRequest* request, ::controller::SetParamResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetJointSoftLimit(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::controller::GetJointParamsResponse* response, std::function<void(::grpc::Status)>) override;
      void GetJointSoftLimit(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::controller::GetJointParamsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetJointMaxVel(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::controller::GetJointParamsResponse* response, std::function<void(::grpc::Status)>) override;
      void GetJointMaxVel(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::controller::GetJointParamsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetJointMaxAcc(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::controller::GetJointParamsResponse* response, std::function<void(::grpc::Status)>) override;
      void GetJointMaxAcc(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::controller::GetJointParamsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetCartesianTranslationMaxVel(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::controller::GetCartesianParamsResponse* response, std::function<void(::grpc::Status)>) override;
      void GetCartesianTranslationMaxVel(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::controller::GetCartesianParamsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetCartesianTranslationMaxAcc(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::controller::GetCartesianParamsResponse* response, std::function<void(::grpc::Status)>) override;
      void GetCartesianTranslationMaxAcc(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::controller::GetCartesianParamsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetCartesianRotationMaxVel(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::controller::GetCartesianParamsResponse* response, std::function<void(::grpc::Status)>) override;
      void GetCartesianRotationMaxVel(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::controller::GetCartesianParamsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetCartesianRotationMaxAcc(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::controller::GetCartesianParamsResponse* response, std::function<void(::grpc::Status)>) override;
      void GetCartesianRotationMaxAcc(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::controller::GetCartesianParamsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetTcpOffset(::grpc::ClientContext* context, const ::controller::GetTcpOffsetRequest* request, ::controller::GetTcpOffsetResponse* response, std::function<void(::grpc::Status)>) override;
      void GetTcpOffset(::grpc::ClientContext* context, const ::controller::GetTcpOffsetRequest* request, ::controller::GetTcpOffsetResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetTcpPayload(::grpc::ClientContext* context, const ::controller::GetTcpPayloadRequest* request, ::controller::GetTcpPayloadResponse* response, std::function<void(::grpc::Status)>) override;
      void GetTcpPayload(::grpc::ClientContext* context, const ::controller::GetTcpPayloadRequest* request, ::controller::GetTcpPayloadResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ForwardKinematics(::grpc::ClientContext* context, const ::controller::ForwardKinematicsRequest* request, ::controller::ForwardKinematicsResponse* response, std::function<void(::grpc::Status)>) override;
      void ForwardKinematics(::grpc::ClientContext* context, const ::controller::ForwardKinematicsRequest* request, ::controller::ForwardKinematicsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void InverseKinematics(::grpc::ClientContext* context, const ::controller::InverseKinematicsRequest* request, ::controller::InverseKinematicsResponse* response, std::function<void(::grpc::Status)>) override;
      void InverseKinematics(::grpc::ClientContext* context, const ::controller::InverseKinematicsRequest* request, ::controller::InverseKinematicsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetJointMechanicalLimit(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::controller::GetJointParamsResponse* response, std::function<void(::grpc::Status)>) override;
      void GetJointMechanicalLimit(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::controller::GetJointParamsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetJointMechanicalMaxVel(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::controller::GetJointParamsResponse* response, std::function<void(::grpc::Status)>) override;
      void GetJointMechanicalMaxVel(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::controller::GetJointParamsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetJointMechanicalMaxAcc(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::controller::GetJointParamsResponse* response, std::function<void(::grpc::Status)>) override;
      void GetJointMechanicalMaxAcc(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::controller::GetJointParamsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetCartesianMechanicalTranslationMaxVel(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::controller::GetCartesianParamsResponse* response, std::function<void(::grpc::Status)>) override;
      void GetCartesianMechanicalTranslationMaxVel(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::controller::GetCartesianParamsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetCartesianMechanicalTranslationMaxAcc(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::controller::GetCartesianParamsResponse* response, std::function<void(::grpc::Status)>) override;
      void GetCartesianMechanicalTranslationMaxAcc(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::controller::GetCartesianParamsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetCartesianMechanicalRotationMaxVel(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::controller::GetCartesianParamsResponse* response, std::function<void(::grpc::Status)>) override;
      void GetCartesianMechanicalRotationMaxVel(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::controller::GetCartesianParamsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetCartesianMechanicalRotationMaxAcc(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::controller::GetCartesianParamsResponse* response, std::function<void(::grpc::Status)>) override;
      void GetCartesianMechanicalRotationMaxAcc(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::controller::GetCartesianParamsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::controller::SetParamResponse>* AsyncSetJointSoftLimitRaw(::grpc::ClientContext* context, const ::controller::SetJointParamsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::controller::SetParamResponse>* PrepareAsyncSetJointSoftLimitRaw(::grpc::ClientContext* context, const ::controller::SetJointParamsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::controller::SetParamResponse>* AsyncSetJointMaxVelRaw(::grpc::ClientContext* context, const ::controller::SetJointParamsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::controller::SetParamResponse>* PrepareAsyncSetJointMaxVelRaw(::grpc::ClientContext* context, const ::controller::SetJointParamsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::controller::SetParamResponse>* AsyncSetJointMaxAccRaw(::grpc::ClientContext* context, const ::controller::SetJointParamsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::controller::SetParamResponse>* PrepareAsyncSetJointMaxAccRaw(::grpc::ClientContext* context, const ::controller::SetJointParamsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::controller::SetParamResponse>* AsyncSetCartesianTranslationMaxVelRaw(::grpc::ClientContext* context, const ::controller::SetCartesianParamsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::controller::SetParamResponse>* PrepareAsyncSetCartesianTranslationMaxVelRaw(::grpc::ClientContext* context, const ::controller::SetCartesianParamsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::controller::SetParamResponse>* AsyncSetCartesianTranslationMaxAccRaw(::grpc::ClientContext* context, const ::controller::SetCartesianParamsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::controller::SetParamResponse>* PrepareAsyncSetCartesianTranslationMaxAccRaw(::grpc::ClientContext* context, const ::controller::SetCartesianParamsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::controller::SetParamResponse>* AsyncSetCartesianRotationMaxVelRaw(::grpc::ClientContext* context, const ::controller::SetCartesianParamsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::controller::SetParamResponse>* PrepareAsyncSetCartesianRotationMaxVelRaw(::grpc::ClientContext* context, const ::controller::SetCartesianParamsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::controller::SetParamResponse>* AsyncSetCartesianRotationMaxAccRaw(::grpc::ClientContext* context, const ::controller::SetCartesianParamsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::controller::SetParamResponse>* PrepareAsyncSetCartesianRotationMaxAccRaw(::grpc::ClientContext* context, const ::controller::SetCartesianParamsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::controller::SetParamResponse>* AsyncSetTcpOffsetRaw(::grpc::ClientContext* context, const ::controller::SetTcpOffsetParamsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::controller::SetParamResponse>* PrepareAsyncSetTcpOffsetRaw(::grpc::ClientContext* context, const ::controller::SetTcpOffsetParamsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::controller::SetParamResponse>* AsyncSetTcpPayloadRaw(::grpc::ClientContext* context, const ::controller::SetTcpPayloadParamsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::controller::SetParamResponse>* PrepareAsyncSetTcpPayloadRaw(::grpc::ClientContext* context, const ::controller::SetTcpPayloadParamsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::controller::GetJointParamsResponse>* AsyncGetJointSoftLimitRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::controller::GetJointParamsResponse>* PrepareAsyncGetJointSoftLimitRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::controller::GetJointParamsResponse>* AsyncGetJointMaxVelRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::controller::GetJointParamsResponse>* PrepareAsyncGetJointMaxVelRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::controller::GetJointParamsResponse>* AsyncGetJointMaxAccRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::controller::GetJointParamsResponse>* PrepareAsyncGetJointMaxAccRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::controller::GetCartesianParamsResponse>* AsyncGetCartesianTranslationMaxVelRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::controller::GetCartesianParamsResponse>* PrepareAsyncGetCartesianTranslationMaxVelRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::controller::GetCartesianParamsResponse>* AsyncGetCartesianTranslationMaxAccRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::controller::GetCartesianParamsResponse>* PrepareAsyncGetCartesianTranslationMaxAccRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::controller::GetCartesianParamsResponse>* AsyncGetCartesianRotationMaxVelRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::controller::GetCartesianParamsResponse>* PrepareAsyncGetCartesianRotationMaxVelRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::controller::GetCartesianParamsResponse>* AsyncGetCartesianRotationMaxAccRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::controller::GetCartesianParamsResponse>* PrepareAsyncGetCartesianRotationMaxAccRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::controller::GetTcpOffsetResponse>* AsyncGetTcpOffsetRaw(::grpc::ClientContext* context, const ::controller::GetTcpOffsetRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::controller::GetTcpOffsetResponse>* PrepareAsyncGetTcpOffsetRaw(::grpc::ClientContext* context, const ::controller::GetTcpOffsetRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::controller::GetTcpPayloadResponse>* AsyncGetTcpPayloadRaw(::grpc::ClientContext* context, const ::controller::GetTcpPayloadRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::controller::GetTcpPayloadResponse>* PrepareAsyncGetTcpPayloadRaw(::grpc::ClientContext* context, const ::controller::GetTcpPayloadRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::controller::ForwardKinematicsResponse>* AsyncForwardKinematicsRaw(::grpc::ClientContext* context, const ::controller::ForwardKinematicsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::controller::ForwardKinematicsResponse>* PrepareAsyncForwardKinematicsRaw(::grpc::ClientContext* context, const ::controller::ForwardKinematicsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::controller::InverseKinematicsResponse>* AsyncInverseKinematicsRaw(::grpc::ClientContext* context, const ::controller::InverseKinematicsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::controller::InverseKinematicsResponse>* PrepareAsyncInverseKinematicsRaw(::grpc::ClientContext* context, const ::controller::InverseKinematicsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::controller::GetJointParamsResponse>* AsyncGetJointMechanicalLimitRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::controller::GetJointParamsResponse>* PrepareAsyncGetJointMechanicalLimitRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::controller::GetJointParamsResponse>* AsyncGetJointMechanicalMaxVelRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::controller::GetJointParamsResponse>* PrepareAsyncGetJointMechanicalMaxVelRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::controller::GetJointParamsResponse>* AsyncGetJointMechanicalMaxAccRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::controller::GetJointParamsResponse>* PrepareAsyncGetJointMechanicalMaxAccRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::controller::GetCartesianParamsResponse>* AsyncGetCartesianMechanicalTranslationMaxVelRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::controller::GetCartesianParamsResponse>* PrepareAsyncGetCartesianMechanicalTranslationMaxVelRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::controller::GetCartesianParamsResponse>* AsyncGetCartesianMechanicalTranslationMaxAccRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::controller::GetCartesianParamsResponse>* PrepareAsyncGetCartesianMechanicalTranslationMaxAccRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::controller::GetCartesianParamsResponse>* AsyncGetCartesianMechanicalRotationMaxVelRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::controller::GetCartesianParamsResponse>* PrepareAsyncGetCartesianMechanicalRotationMaxVelRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::controller::GetCartesianParamsResponse>* AsyncGetCartesianMechanicalRotationMaxAccRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::controller::GetCartesianParamsResponse>* PrepareAsyncGetCartesianMechanicalRotationMaxAccRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_SetJointSoftLimit_;
    const ::grpc::internal::RpcMethod rpcmethod_SetJointMaxVel_;
    const ::grpc::internal::RpcMethod rpcmethod_SetJointMaxAcc_;
    const ::grpc::internal::RpcMethod rpcmethod_SetCartesianTranslationMaxVel_;
    const ::grpc::internal::RpcMethod rpcmethod_SetCartesianTranslationMaxAcc_;
    const ::grpc::internal::RpcMethod rpcmethod_SetCartesianRotationMaxVel_;
    const ::grpc::internal::RpcMethod rpcmethod_SetCartesianRotationMaxAcc_;
    const ::grpc::internal::RpcMethod rpcmethod_SetTcpOffset_;
    const ::grpc::internal::RpcMethod rpcmethod_SetTcpPayload_;
    const ::grpc::internal::RpcMethod rpcmethod_GetJointSoftLimit_;
    const ::grpc::internal::RpcMethod rpcmethod_GetJointMaxVel_;
    const ::grpc::internal::RpcMethod rpcmethod_GetJointMaxAcc_;
    const ::grpc::internal::RpcMethod rpcmethod_GetCartesianTranslationMaxVel_;
    const ::grpc::internal::RpcMethod rpcmethod_GetCartesianTranslationMaxAcc_;
    const ::grpc::internal::RpcMethod rpcmethod_GetCartesianRotationMaxVel_;
    const ::grpc::internal::RpcMethod rpcmethod_GetCartesianRotationMaxAcc_;
    const ::grpc::internal::RpcMethod rpcmethod_GetTcpOffset_;
    const ::grpc::internal::RpcMethod rpcmethod_GetTcpPayload_;
    const ::grpc::internal::RpcMethod rpcmethod_ForwardKinematics_;
    const ::grpc::internal::RpcMethod rpcmethod_InverseKinematics_;
    const ::grpc::internal::RpcMethod rpcmethod_GetJointMechanicalLimit_;
    const ::grpc::internal::RpcMethod rpcmethod_GetJointMechanicalMaxVel_;
    const ::grpc::internal::RpcMethod rpcmethod_GetJointMechanicalMaxAcc_;
    const ::grpc::internal::RpcMethod rpcmethod_GetCartesianMechanicalTranslationMaxVel_;
    const ::grpc::internal::RpcMethod rpcmethod_GetCartesianMechanicalTranslationMaxAcc_;
    const ::grpc::internal::RpcMethod rpcmethod_GetCartesianMechanicalRotationMaxVel_;
    const ::grpc::internal::RpcMethod rpcmethod_GetCartesianMechanicalRotationMaxAcc_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // set rpc
    virtual ::grpc::Status SetJointSoftLimit(::grpc::ServerContext* context, const ::controller::SetJointParamsRequest* request, ::controller::SetParamResponse* response);
    virtual ::grpc::Status SetJointMaxVel(::grpc::ServerContext* context, const ::controller::SetJointParamsRequest* request, ::controller::SetParamResponse* response);
    virtual ::grpc::Status SetJointMaxAcc(::grpc::ServerContext* context, const ::controller::SetJointParamsRequest* request, ::controller::SetParamResponse* response);
    virtual ::grpc::Status SetCartesianTranslationMaxVel(::grpc::ServerContext* context, const ::controller::SetCartesianParamsRequest* request, ::controller::SetParamResponse* response);
    virtual ::grpc::Status SetCartesianTranslationMaxAcc(::grpc::ServerContext* context, const ::controller::SetCartesianParamsRequest* request, ::controller::SetParamResponse* response);
    virtual ::grpc::Status SetCartesianRotationMaxVel(::grpc::ServerContext* context, const ::controller::SetCartesianParamsRequest* request, ::controller::SetParamResponse* response);
    virtual ::grpc::Status SetCartesianRotationMaxAcc(::grpc::ServerContext* context, const ::controller::SetCartesianParamsRequest* request, ::controller::SetParamResponse* response);
    virtual ::grpc::Status SetTcpOffset(::grpc::ServerContext* context, const ::controller::SetTcpOffsetParamsRequest* request, ::controller::SetParamResponse* response);
    virtual ::grpc::Status SetTcpPayload(::grpc::ServerContext* context, const ::controller::SetTcpPayloadParamsRequest* request, ::controller::SetParamResponse* response);
    // get rpc
    virtual ::grpc::Status GetJointSoftLimit(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::controller::GetJointParamsResponse* response);
    virtual ::grpc::Status GetJointMaxVel(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::controller::GetJointParamsResponse* response);
    virtual ::grpc::Status GetJointMaxAcc(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::controller::GetJointParamsResponse* response);
    virtual ::grpc::Status GetCartesianTranslationMaxVel(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::controller::GetCartesianParamsResponse* response);
    virtual ::grpc::Status GetCartesianTranslationMaxAcc(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::controller::GetCartesianParamsResponse* response);
    virtual ::grpc::Status GetCartesianRotationMaxVel(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::controller::GetCartesianParamsResponse* response);
    virtual ::grpc::Status GetCartesianRotationMaxAcc(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::controller::GetCartesianParamsResponse* response);
    virtual ::grpc::Status GetTcpOffset(::grpc::ServerContext* context, const ::controller::GetTcpOffsetRequest* request, ::controller::GetTcpOffsetResponse* response);
    virtual ::grpc::Status GetTcpPayload(::grpc::ServerContext* context, const ::controller::GetTcpPayloadRequest* request, ::controller::GetTcpPayloadResponse* response);
    virtual ::grpc::Status ForwardKinematics(::grpc::ServerContext* context, const ::controller::ForwardKinematicsRequest* request, ::controller::ForwardKinematicsResponse* response);
    virtual ::grpc::Status InverseKinematics(::grpc::ServerContext* context, const ::controller::InverseKinematicsRequest* request, ::controller::InverseKinematicsResponse* response);
    // get mechanical
    virtual ::grpc::Status GetJointMechanicalLimit(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::controller::GetJointParamsResponse* response);
    virtual ::grpc::Status GetJointMechanicalMaxVel(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::controller::GetJointParamsResponse* response);
    virtual ::grpc::Status GetJointMechanicalMaxAcc(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::controller::GetJointParamsResponse* response);
    virtual ::grpc::Status GetCartesianMechanicalTranslationMaxVel(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::controller::GetCartesianParamsResponse* response);
    virtual ::grpc::Status GetCartesianMechanicalTranslationMaxAcc(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::controller::GetCartesianParamsResponse* response);
    virtual ::grpc::Status GetCartesianMechanicalRotationMaxVel(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::controller::GetCartesianParamsResponse* response);
    virtual ::grpc::Status GetCartesianMechanicalRotationMaxAcc(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::controller::GetCartesianParamsResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_SetJointSoftLimit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetJointSoftLimit() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_SetJointSoftLimit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetJointSoftLimit(::grpc::ServerContext* /*context*/, const ::controller::SetJointParamsRequest* /*request*/, ::controller::SetParamResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetJointSoftLimit(::grpc::ServerContext* context, ::controller::SetJointParamsRequest* request, ::grpc::ServerAsyncResponseWriter< ::controller::SetParamResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetJointMaxVel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetJointMaxVel() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_SetJointMaxVel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetJointMaxVel(::grpc::ServerContext* /*context*/, const ::controller::SetJointParamsRequest* /*request*/, ::controller::SetParamResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetJointMaxVel(::grpc::ServerContext* context, ::controller::SetJointParamsRequest* request, ::grpc::ServerAsyncResponseWriter< ::controller::SetParamResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetJointMaxAcc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetJointMaxAcc() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_SetJointMaxAcc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetJointMaxAcc(::grpc::ServerContext* /*context*/, const ::controller::SetJointParamsRequest* /*request*/, ::controller::SetParamResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetJointMaxAcc(::grpc::ServerContext* context, ::controller::SetJointParamsRequest* request, ::grpc::ServerAsyncResponseWriter< ::controller::SetParamResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetCartesianTranslationMaxVel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetCartesianTranslationMaxVel() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_SetCartesianTranslationMaxVel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCartesianTranslationMaxVel(::grpc::ServerContext* /*context*/, const ::controller::SetCartesianParamsRequest* /*request*/, ::controller::SetParamResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetCartesianTranslationMaxVel(::grpc::ServerContext* context, ::controller::SetCartesianParamsRequest* request, ::grpc::ServerAsyncResponseWriter< ::controller::SetParamResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetCartesianTranslationMaxAcc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetCartesianTranslationMaxAcc() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_SetCartesianTranslationMaxAcc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCartesianTranslationMaxAcc(::grpc::ServerContext* /*context*/, const ::controller::SetCartesianParamsRequest* /*request*/, ::controller::SetParamResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetCartesianTranslationMaxAcc(::grpc::ServerContext* context, ::controller::SetCartesianParamsRequest* request, ::grpc::ServerAsyncResponseWriter< ::controller::SetParamResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetCartesianRotationMaxVel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetCartesianRotationMaxVel() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_SetCartesianRotationMaxVel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCartesianRotationMaxVel(::grpc::ServerContext* /*context*/, const ::controller::SetCartesianParamsRequest* /*request*/, ::controller::SetParamResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetCartesianRotationMaxVel(::grpc::ServerContext* context, ::controller::SetCartesianParamsRequest* request, ::grpc::ServerAsyncResponseWriter< ::controller::SetParamResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetCartesianRotationMaxAcc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetCartesianRotationMaxAcc() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_SetCartesianRotationMaxAcc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCartesianRotationMaxAcc(::grpc::ServerContext* /*context*/, const ::controller::SetCartesianParamsRequest* /*request*/, ::controller::SetParamResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetCartesianRotationMaxAcc(::grpc::ServerContext* context, ::controller::SetCartesianParamsRequest* request, ::grpc::ServerAsyncResponseWriter< ::controller::SetParamResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetTcpOffset : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetTcpOffset() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_SetTcpOffset() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetTcpOffset(::grpc::ServerContext* /*context*/, const ::controller::SetTcpOffsetParamsRequest* /*request*/, ::controller::SetParamResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetTcpOffset(::grpc::ServerContext* context, ::controller::SetTcpOffsetParamsRequest* request, ::grpc::ServerAsyncResponseWriter< ::controller::SetParamResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetTcpPayload : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetTcpPayload() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_SetTcpPayload() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetTcpPayload(::grpc::ServerContext* /*context*/, const ::controller::SetTcpPayloadParamsRequest* /*request*/, ::controller::SetParamResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetTcpPayload(::grpc::ServerContext* context, ::controller::SetTcpPayloadParamsRequest* request, ::grpc::ServerAsyncResponseWriter< ::controller::SetParamResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetJointSoftLimit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetJointSoftLimit() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_GetJointSoftLimit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetJointSoftLimit(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetJointParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetJointSoftLimit(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::controller::GetJointParamsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetJointMaxVel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetJointMaxVel() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_GetJointMaxVel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetJointMaxVel(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetJointParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetJointMaxVel(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::controller::GetJointParamsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetJointMaxAcc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetJointMaxAcc() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_GetJointMaxAcc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetJointMaxAcc(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetJointParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetJointMaxAcc(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::controller::GetJointParamsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetCartesianTranslationMaxVel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetCartesianTranslationMaxVel() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_GetCartesianTranslationMaxVel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCartesianTranslationMaxVel(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetCartesianParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetCartesianTranslationMaxVel(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::controller::GetCartesianParamsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetCartesianTranslationMaxAcc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetCartesianTranslationMaxAcc() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_GetCartesianTranslationMaxAcc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCartesianTranslationMaxAcc(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetCartesianParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetCartesianTranslationMaxAcc(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::controller::GetCartesianParamsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetCartesianRotationMaxVel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetCartesianRotationMaxVel() {
      ::grpc::Service::MarkMethodAsync(14);
    }
    ~WithAsyncMethod_GetCartesianRotationMaxVel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCartesianRotationMaxVel(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetCartesianParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetCartesianRotationMaxVel(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::controller::GetCartesianParamsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetCartesianRotationMaxAcc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetCartesianRotationMaxAcc() {
      ::grpc::Service::MarkMethodAsync(15);
    }
    ~WithAsyncMethod_GetCartesianRotationMaxAcc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCartesianRotationMaxAcc(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetCartesianParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetCartesianRotationMaxAcc(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::controller::GetCartesianParamsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetTcpOffset : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetTcpOffset() {
      ::grpc::Service::MarkMethodAsync(16);
    }
    ~WithAsyncMethod_GetTcpOffset() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTcpOffset(::grpc::ServerContext* /*context*/, const ::controller::GetTcpOffsetRequest* /*request*/, ::controller::GetTcpOffsetResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetTcpOffset(::grpc::ServerContext* context, ::controller::GetTcpOffsetRequest* request, ::grpc::ServerAsyncResponseWriter< ::controller::GetTcpOffsetResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetTcpPayload : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetTcpPayload() {
      ::grpc::Service::MarkMethodAsync(17);
    }
    ~WithAsyncMethod_GetTcpPayload() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTcpPayload(::grpc::ServerContext* /*context*/, const ::controller::GetTcpPayloadRequest* /*request*/, ::controller::GetTcpPayloadResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetTcpPayload(::grpc::ServerContext* context, ::controller::GetTcpPayloadRequest* request, ::grpc::ServerAsyncResponseWriter< ::controller::GetTcpPayloadResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ForwardKinematics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ForwardKinematics() {
      ::grpc::Service::MarkMethodAsync(18);
    }
    ~WithAsyncMethod_ForwardKinematics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ForwardKinematics(::grpc::ServerContext* /*context*/, const ::controller::ForwardKinematicsRequest* /*request*/, ::controller::ForwardKinematicsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestForwardKinematics(::grpc::ServerContext* context, ::controller::ForwardKinematicsRequest* request, ::grpc::ServerAsyncResponseWriter< ::controller::ForwardKinematicsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_InverseKinematics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_InverseKinematics() {
      ::grpc::Service::MarkMethodAsync(19);
    }
    ~WithAsyncMethod_InverseKinematics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status InverseKinematics(::grpc::ServerContext* /*context*/, const ::controller::InverseKinematicsRequest* /*request*/, ::controller::InverseKinematicsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestInverseKinematics(::grpc::ServerContext* context, ::controller::InverseKinematicsRequest* request, ::grpc::ServerAsyncResponseWriter< ::controller::InverseKinematicsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetJointMechanicalLimit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetJointMechanicalLimit() {
      ::grpc::Service::MarkMethodAsync(20);
    }
    ~WithAsyncMethod_GetJointMechanicalLimit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetJointMechanicalLimit(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetJointParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetJointMechanicalLimit(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::controller::GetJointParamsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetJointMechanicalMaxVel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetJointMechanicalMaxVel() {
      ::grpc::Service::MarkMethodAsync(21);
    }
    ~WithAsyncMethod_GetJointMechanicalMaxVel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetJointMechanicalMaxVel(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetJointParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetJointMechanicalMaxVel(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::controller::GetJointParamsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetJointMechanicalMaxAcc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetJointMechanicalMaxAcc() {
      ::grpc::Service::MarkMethodAsync(22);
    }
    ~WithAsyncMethod_GetJointMechanicalMaxAcc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetJointMechanicalMaxAcc(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetJointParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetJointMechanicalMaxAcc(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::controller::GetJointParamsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(22, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetCartesianMechanicalTranslationMaxVel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetCartesianMechanicalTranslationMaxVel() {
      ::grpc::Service::MarkMethodAsync(23);
    }
    ~WithAsyncMethod_GetCartesianMechanicalTranslationMaxVel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCartesianMechanicalTranslationMaxVel(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetCartesianParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetCartesianMechanicalTranslationMaxVel(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::controller::GetCartesianParamsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(23, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetCartesianMechanicalTranslationMaxAcc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetCartesianMechanicalTranslationMaxAcc() {
      ::grpc::Service::MarkMethodAsync(24);
    }
    ~WithAsyncMethod_GetCartesianMechanicalTranslationMaxAcc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCartesianMechanicalTranslationMaxAcc(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetCartesianParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetCartesianMechanicalTranslationMaxAcc(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::controller::GetCartesianParamsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(24, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetCartesianMechanicalRotationMaxVel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetCartesianMechanicalRotationMaxVel() {
      ::grpc::Service::MarkMethodAsync(25);
    }
    ~WithAsyncMethod_GetCartesianMechanicalRotationMaxVel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCartesianMechanicalRotationMaxVel(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetCartesianParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetCartesianMechanicalRotationMaxVel(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::controller::GetCartesianParamsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(25, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetCartesianMechanicalRotationMaxAcc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetCartesianMechanicalRotationMaxAcc() {
      ::grpc::Service::MarkMethodAsync(26);
    }
    ~WithAsyncMethod_GetCartesianMechanicalRotationMaxAcc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCartesianMechanicalRotationMaxAcc(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetCartesianParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetCartesianMechanicalRotationMaxAcc(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::controller::GetCartesianParamsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(26, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_SetJointSoftLimit<WithAsyncMethod_SetJointMaxVel<WithAsyncMethod_SetJointMaxAcc<WithAsyncMethod_SetCartesianTranslationMaxVel<WithAsyncMethod_SetCartesianTranslationMaxAcc<WithAsyncMethod_SetCartesianRotationMaxVel<WithAsyncMethod_SetCartesianRotationMaxAcc<WithAsyncMethod_SetTcpOffset<WithAsyncMethod_SetTcpPayload<WithAsyncMethod_GetJointSoftLimit<WithAsyncMethod_GetJointMaxVel<WithAsyncMethod_GetJointMaxAcc<WithAsyncMethod_GetCartesianTranslationMaxVel<WithAsyncMethod_GetCartesianTranslationMaxAcc<WithAsyncMethod_GetCartesianRotationMaxVel<WithAsyncMethod_GetCartesianRotationMaxAcc<WithAsyncMethod_GetTcpOffset<WithAsyncMethod_GetTcpPayload<WithAsyncMethod_ForwardKinematics<WithAsyncMethod_InverseKinematics<WithAsyncMethod_GetJointMechanicalLimit<WithAsyncMethod_GetJointMechanicalMaxVel<WithAsyncMethod_GetJointMechanicalMaxAcc<WithAsyncMethod_GetCartesianMechanicalTranslationMaxVel<WithAsyncMethod_GetCartesianMechanicalTranslationMaxAcc<WithAsyncMethod_GetCartesianMechanicalRotationMaxVel<WithAsyncMethod_GetCartesianMechanicalRotationMaxAcc<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_SetJointSoftLimit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetJointSoftLimit() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::controller::SetJointParamsRequest, ::controller::SetParamResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::controller::SetJointParamsRequest* request, ::controller::SetParamResponse* response) { return this->SetJointSoftLimit(context, request, response); }));}
    void SetMessageAllocatorFor_SetJointSoftLimit(
        ::grpc::MessageAllocator< ::controller::SetJointParamsRequest, ::controller::SetParamResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::controller::SetJointParamsRequest, ::controller::SetParamResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetJointSoftLimit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetJointSoftLimit(::grpc::ServerContext* /*context*/, const ::controller::SetJointParamsRequest* /*request*/, ::controller::SetParamResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetJointSoftLimit(
      ::grpc::CallbackServerContext* /*context*/, const ::controller::SetJointParamsRequest* /*request*/, ::controller::SetParamResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetJointMaxVel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetJointMaxVel() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::controller::SetJointParamsRequest, ::controller::SetParamResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::controller::SetJointParamsRequest* request, ::controller::SetParamResponse* response) { return this->SetJointMaxVel(context, request, response); }));}
    void SetMessageAllocatorFor_SetJointMaxVel(
        ::grpc::MessageAllocator< ::controller::SetJointParamsRequest, ::controller::SetParamResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::controller::SetJointParamsRequest, ::controller::SetParamResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetJointMaxVel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetJointMaxVel(::grpc::ServerContext* /*context*/, const ::controller::SetJointParamsRequest* /*request*/, ::controller::SetParamResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetJointMaxVel(
      ::grpc::CallbackServerContext* /*context*/, const ::controller::SetJointParamsRequest* /*request*/, ::controller::SetParamResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetJointMaxAcc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetJointMaxAcc() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::controller::SetJointParamsRequest, ::controller::SetParamResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::controller::SetJointParamsRequest* request, ::controller::SetParamResponse* response) { return this->SetJointMaxAcc(context, request, response); }));}
    void SetMessageAllocatorFor_SetJointMaxAcc(
        ::grpc::MessageAllocator< ::controller::SetJointParamsRequest, ::controller::SetParamResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::controller::SetJointParamsRequest, ::controller::SetParamResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetJointMaxAcc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetJointMaxAcc(::grpc::ServerContext* /*context*/, const ::controller::SetJointParamsRequest* /*request*/, ::controller::SetParamResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetJointMaxAcc(
      ::grpc::CallbackServerContext* /*context*/, const ::controller::SetJointParamsRequest* /*request*/, ::controller::SetParamResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetCartesianTranslationMaxVel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetCartesianTranslationMaxVel() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::controller::SetCartesianParamsRequest, ::controller::SetParamResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::controller::SetCartesianParamsRequest* request, ::controller::SetParamResponse* response) { return this->SetCartesianTranslationMaxVel(context, request, response); }));}
    void SetMessageAllocatorFor_SetCartesianTranslationMaxVel(
        ::grpc::MessageAllocator< ::controller::SetCartesianParamsRequest, ::controller::SetParamResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::controller::SetCartesianParamsRequest, ::controller::SetParamResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetCartesianTranslationMaxVel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCartesianTranslationMaxVel(::grpc::ServerContext* /*context*/, const ::controller::SetCartesianParamsRequest* /*request*/, ::controller::SetParamResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetCartesianTranslationMaxVel(
      ::grpc::CallbackServerContext* /*context*/, const ::controller::SetCartesianParamsRequest* /*request*/, ::controller::SetParamResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetCartesianTranslationMaxAcc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetCartesianTranslationMaxAcc() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::controller::SetCartesianParamsRequest, ::controller::SetParamResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::controller::SetCartesianParamsRequest* request, ::controller::SetParamResponse* response) { return this->SetCartesianTranslationMaxAcc(context, request, response); }));}
    void SetMessageAllocatorFor_SetCartesianTranslationMaxAcc(
        ::grpc::MessageAllocator< ::controller::SetCartesianParamsRequest, ::controller::SetParamResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::controller::SetCartesianParamsRequest, ::controller::SetParamResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetCartesianTranslationMaxAcc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCartesianTranslationMaxAcc(::grpc::ServerContext* /*context*/, const ::controller::SetCartesianParamsRequest* /*request*/, ::controller::SetParamResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetCartesianTranslationMaxAcc(
      ::grpc::CallbackServerContext* /*context*/, const ::controller::SetCartesianParamsRequest* /*request*/, ::controller::SetParamResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetCartesianRotationMaxVel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetCartesianRotationMaxVel() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::controller::SetCartesianParamsRequest, ::controller::SetParamResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::controller::SetCartesianParamsRequest* request, ::controller::SetParamResponse* response) { return this->SetCartesianRotationMaxVel(context, request, response); }));}
    void SetMessageAllocatorFor_SetCartesianRotationMaxVel(
        ::grpc::MessageAllocator< ::controller::SetCartesianParamsRequest, ::controller::SetParamResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::controller::SetCartesianParamsRequest, ::controller::SetParamResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetCartesianRotationMaxVel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCartesianRotationMaxVel(::grpc::ServerContext* /*context*/, const ::controller::SetCartesianParamsRequest* /*request*/, ::controller::SetParamResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetCartesianRotationMaxVel(
      ::grpc::CallbackServerContext* /*context*/, const ::controller::SetCartesianParamsRequest* /*request*/, ::controller::SetParamResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetCartesianRotationMaxAcc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetCartesianRotationMaxAcc() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::controller::SetCartesianParamsRequest, ::controller::SetParamResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::controller::SetCartesianParamsRequest* request, ::controller::SetParamResponse* response) { return this->SetCartesianRotationMaxAcc(context, request, response); }));}
    void SetMessageAllocatorFor_SetCartesianRotationMaxAcc(
        ::grpc::MessageAllocator< ::controller::SetCartesianParamsRequest, ::controller::SetParamResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::controller::SetCartesianParamsRequest, ::controller::SetParamResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetCartesianRotationMaxAcc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCartesianRotationMaxAcc(::grpc::ServerContext* /*context*/, const ::controller::SetCartesianParamsRequest* /*request*/, ::controller::SetParamResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetCartesianRotationMaxAcc(
      ::grpc::CallbackServerContext* /*context*/, const ::controller::SetCartesianParamsRequest* /*request*/, ::controller::SetParamResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetTcpOffset : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetTcpOffset() {
      ::grpc::Service::MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::controller::SetTcpOffsetParamsRequest, ::controller::SetParamResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::controller::SetTcpOffsetParamsRequest* request, ::controller::SetParamResponse* response) { return this->SetTcpOffset(context, request, response); }));}
    void SetMessageAllocatorFor_SetTcpOffset(
        ::grpc::MessageAllocator< ::controller::SetTcpOffsetParamsRequest, ::controller::SetParamResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::controller::SetTcpOffsetParamsRequest, ::controller::SetParamResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetTcpOffset() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetTcpOffset(::grpc::ServerContext* /*context*/, const ::controller::SetTcpOffsetParamsRequest* /*request*/, ::controller::SetParamResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetTcpOffset(
      ::grpc::CallbackServerContext* /*context*/, const ::controller::SetTcpOffsetParamsRequest* /*request*/, ::controller::SetParamResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetTcpPayload : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetTcpPayload() {
      ::grpc::Service::MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::controller::SetTcpPayloadParamsRequest, ::controller::SetParamResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::controller::SetTcpPayloadParamsRequest* request, ::controller::SetParamResponse* response) { return this->SetTcpPayload(context, request, response); }));}
    void SetMessageAllocatorFor_SetTcpPayload(
        ::grpc::MessageAllocator< ::controller::SetTcpPayloadParamsRequest, ::controller::SetParamResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::controller::SetTcpPayloadParamsRequest, ::controller::SetParamResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetTcpPayload() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetTcpPayload(::grpc::ServerContext* /*context*/, const ::controller::SetTcpPayloadParamsRequest* /*request*/, ::controller::SetParamResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetTcpPayload(
      ::grpc::CallbackServerContext* /*context*/, const ::controller::SetTcpPayloadParamsRequest* /*request*/, ::controller::SetParamResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetJointSoftLimit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetJointSoftLimit() {
      ::grpc::Service::MarkMethodCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::controller::GetJointParamsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::google::protobuf::Empty* request, ::controller::GetJointParamsResponse* response) { return this->GetJointSoftLimit(context, request, response); }));}
    void SetMessageAllocatorFor_GetJointSoftLimit(
        ::grpc::MessageAllocator< ::google::protobuf::Empty, ::controller::GetJointParamsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::controller::GetJointParamsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetJointSoftLimit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetJointSoftLimit(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetJointParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetJointSoftLimit(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetJointParamsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetJointMaxVel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetJointMaxVel() {
      ::grpc::Service::MarkMethodCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::controller::GetJointParamsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::google::protobuf::Empty* request, ::controller::GetJointParamsResponse* response) { return this->GetJointMaxVel(context, request, response); }));}
    void SetMessageAllocatorFor_GetJointMaxVel(
        ::grpc::MessageAllocator< ::google::protobuf::Empty, ::controller::GetJointParamsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::controller::GetJointParamsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetJointMaxVel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetJointMaxVel(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetJointParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetJointMaxVel(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetJointParamsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetJointMaxAcc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetJointMaxAcc() {
      ::grpc::Service::MarkMethodCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::controller::GetJointParamsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::google::protobuf::Empty* request, ::controller::GetJointParamsResponse* response) { return this->GetJointMaxAcc(context, request, response); }));}
    void SetMessageAllocatorFor_GetJointMaxAcc(
        ::grpc::MessageAllocator< ::google::protobuf::Empty, ::controller::GetJointParamsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(11);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::controller::GetJointParamsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetJointMaxAcc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetJointMaxAcc(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetJointParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetJointMaxAcc(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetJointParamsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetCartesianTranslationMaxVel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetCartesianTranslationMaxVel() {
      ::grpc::Service::MarkMethodCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::controller::GetCartesianParamsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::google::protobuf::Empty* request, ::controller::GetCartesianParamsResponse* response) { return this->GetCartesianTranslationMaxVel(context, request, response); }));}
    void SetMessageAllocatorFor_GetCartesianTranslationMaxVel(
        ::grpc::MessageAllocator< ::google::protobuf::Empty, ::controller::GetCartesianParamsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(12);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::controller::GetCartesianParamsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetCartesianTranslationMaxVel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCartesianTranslationMaxVel(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetCartesianParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetCartesianTranslationMaxVel(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetCartesianParamsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetCartesianTranslationMaxAcc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetCartesianTranslationMaxAcc() {
      ::grpc::Service::MarkMethodCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::controller::GetCartesianParamsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::google::protobuf::Empty* request, ::controller::GetCartesianParamsResponse* response) { return this->GetCartesianTranslationMaxAcc(context, request, response); }));}
    void SetMessageAllocatorFor_GetCartesianTranslationMaxAcc(
        ::grpc::MessageAllocator< ::google::protobuf::Empty, ::controller::GetCartesianParamsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(13);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::controller::GetCartesianParamsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetCartesianTranslationMaxAcc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCartesianTranslationMaxAcc(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetCartesianParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetCartesianTranslationMaxAcc(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetCartesianParamsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetCartesianRotationMaxVel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetCartesianRotationMaxVel() {
      ::grpc::Service::MarkMethodCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::controller::GetCartesianParamsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::google::protobuf::Empty* request, ::controller::GetCartesianParamsResponse* response) { return this->GetCartesianRotationMaxVel(context, request, response); }));}
    void SetMessageAllocatorFor_GetCartesianRotationMaxVel(
        ::grpc::MessageAllocator< ::google::protobuf::Empty, ::controller::GetCartesianParamsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(14);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::controller::GetCartesianParamsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetCartesianRotationMaxVel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCartesianRotationMaxVel(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetCartesianParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetCartesianRotationMaxVel(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetCartesianParamsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetCartesianRotationMaxAcc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetCartesianRotationMaxAcc() {
      ::grpc::Service::MarkMethodCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::controller::GetCartesianParamsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::google::protobuf::Empty* request, ::controller::GetCartesianParamsResponse* response) { return this->GetCartesianRotationMaxAcc(context, request, response); }));}
    void SetMessageAllocatorFor_GetCartesianRotationMaxAcc(
        ::grpc::MessageAllocator< ::google::protobuf::Empty, ::controller::GetCartesianParamsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(15);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::controller::GetCartesianParamsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetCartesianRotationMaxAcc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCartesianRotationMaxAcc(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetCartesianParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetCartesianRotationMaxAcc(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetCartesianParamsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetTcpOffset : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetTcpOffset() {
      ::grpc::Service::MarkMethodCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::controller::GetTcpOffsetRequest, ::controller::GetTcpOffsetResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::controller::GetTcpOffsetRequest* request, ::controller::GetTcpOffsetResponse* response) { return this->GetTcpOffset(context, request, response); }));}
    void SetMessageAllocatorFor_GetTcpOffset(
        ::grpc::MessageAllocator< ::controller::GetTcpOffsetRequest, ::controller::GetTcpOffsetResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(16);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::controller::GetTcpOffsetRequest, ::controller::GetTcpOffsetResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetTcpOffset() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTcpOffset(::grpc::ServerContext* /*context*/, const ::controller::GetTcpOffsetRequest* /*request*/, ::controller::GetTcpOffsetResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetTcpOffset(
      ::grpc::CallbackServerContext* /*context*/, const ::controller::GetTcpOffsetRequest* /*request*/, ::controller::GetTcpOffsetResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetTcpPayload : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetTcpPayload() {
      ::grpc::Service::MarkMethodCallback(17,
          new ::grpc::internal::CallbackUnaryHandler< ::controller::GetTcpPayloadRequest, ::controller::GetTcpPayloadResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::controller::GetTcpPayloadRequest* request, ::controller::GetTcpPayloadResponse* response) { return this->GetTcpPayload(context, request, response); }));}
    void SetMessageAllocatorFor_GetTcpPayload(
        ::grpc::MessageAllocator< ::controller::GetTcpPayloadRequest, ::controller::GetTcpPayloadResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(17);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::controller::GetTcpPayloadRequest, ::controller::GetTcpPayloadResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetTcpPayload() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTcpPayload(::grpc::ServerContext* /*context*/, const ::controller::GetTcpPayloadRequest* /*request*/, ::controller::GetTcpPayloadResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetTcpPayload(
      ::grpc::CallbackServerContext* /*context*/, const ::controller::GetTcpPayloadRequest* /*request*/, ::controller::GetTcpPayloadResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ForwardKinematics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ForwardKinematics() {
      ::grpc::Service::MarkMethodCallback(18,
          new ::grpc::internal::CallbackUnaryHandler< ::controller::ForwardKinematicsRequest, ::controller::ForwardKinematicsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::controller::ForwardKinematicsRequest* request, ::controller::ForwardKinematicsResponse* response) { return this->ForwardKinematics(context, request, response); }));}
    void SetMessageAllocatorFor_ForwardKinematics(
        ::grpc::MessageAllocator< ::controller::ForwardKinematicsRequest, ::controller::ForwardKinematicsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(18);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::controller::ForwardKinematicsRequest, ::controller::ForwardKinematicsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ForwardKinematics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ForwardKinematics(::grpc::ServerContext* /*context*/, const ::controller::ForwardKinematicsRequest* /*request*/, ::controller::ForwardKinematicsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ForwardKinematics(
      ::grpc::CallbackServerContext* /*context*/, const ::controller::ForwardKinematicsRequest* /*request*/, ::controller::ForwardKinematicsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_InverseKinematics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_InverseKinematics() {
      ::grpc::Service::MarkMethodCallback(19,
          new ::grpc::internal::CallbackUnaryHandler< ::controller::InverseKinematicsRequest, ::controller::InverseKinematicsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::controller::InverseKinematicsRequest* request, ::controller::InverseKinematicsResponse* response) { return this->InverseKinematics(context, request, response); }));}
    void SetMessageAllocatorFor_InverseKinematics(
        ::grpc::MessageAllocator< ::controller::InverseKinematicsRequest, ::controller::InverseKinematicsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(19);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::controller::InverseKinematicsRequest, ::controller::InverseKinematicsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_InverseKinematics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status InverseKinematics(::grpc::ServerContext* /*context*/, const ::controller::InverseKinematicsRequest* /*request*/, ::controller::InverseKinematicsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* InverseKinematics(
      ::grpc::CallbackServerContext* /*context*/, const ::controller::InverseKinematicsRequest* /*request*/, ::controller::InverseKinematicsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetJointMechanicalLimit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetJointMechanicalLimit() {
      ::grpc::Service::MarkMethodCallback(20,
          new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::controller::GetJointParamsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::google::protobuf::Empty* request, ::controller::GetJointParamsResponse* response) { return this->GetJointMechanicalLimit(context, request, response); }));}
    void SetMessageAllocatorFor_GetJointMechanicalLimit(
        ::grpc::MessageAllocator< ::google::protobuf::Empty, ::controller::GetJointParamsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(20);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::controller::GetJointParamsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetJointMechanicalLimit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetJointMechanicalLimit(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetJointParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetJointMechanicalLimit(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetJointParamsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetJointMechanicalMaxVel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetJointMechanicalMaxVel() {
      ::grpc::Service::MarkMethodCallback(21,
          new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::controller::GetJointParamsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::google::protobuf::Empty* request, ::controller::GetJointParamsResponse* response) { return this->GetJointMechanicalMaxVel(context, request, response); }));}
    void SetMessageAllocatorFor_GetJointMechanicalMaxVel(
        ::grpc::MessageAllocator< ::google::protobuf::Empty, ::controller::GetJointParamsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(21);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::controller::GetJointParamsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetJointMechanicalMaxVel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetJointMechanicalMaxVel(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetJointParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetJointMechanicalMaxVel(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetJointParamsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetJointMechanicalMaxAcc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetJointMechanicalMaxAcc() {
      ::grpc::Service::MarkMethodCallback(22,
          new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::controller::GetJointParamsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::google::protobuf::Empty* request, ::controller::GetJointParamsResponse* response) { return this->GetJointMechanicalMaxAcc(context, request, response); }));}
    void SetMessageAllocatorFor_GetJointMechanicalMaxAcc(
        ::grpc::MessageAllocator< ::google::protobuf::Empty, ::controller::GetJointParamsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(22);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::controller::GetJointParamsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetJointMechanicalMaxAcc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetJointMechanicalMaxAcc(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetJointParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetJointMechanicalMaxAcc(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetJointParamsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetCartesianMechanicalTranslationMaxVel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetCartesianMechanicalTranslationMaxVel() {
      ::grpc::Service::MarkMethodCallback(23,
          new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::controller::GetCartesianParamsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::google::protobuf::Empty* request, ::controller::GetCartesianParamsResponse* response) { return this->GetCartesianMechanicalTranslationMaxVel(context, request, response); }));}
    void SetMessageAllocatorFor_GetCartesianMechanicalTranslationMaxVel(
        ::grpc::MessageAllocator< ::google::protobuf::Empty, ::controller::GetCartesianParamsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(23);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::controller::GetCartesianParamsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetCartesianMechanicalTranslationMaxVel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCartesianMechanicalTranslationMaxVel(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetCartesianParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetCartesianMechanicalTranslationMaxVel(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetCartesianParamsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetCartesianMechanicalTranslationMaxAcc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetCartesianMechanicalTranslationMaxAcc() {
      ::grpc::Service::MarkMethodCallback(24,
          new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::controller::GetCartesianParamsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::google::protobuf::Empty* request, ::controller::GetCartesianParamsResponse* response) { return this->GetCartesianMechanicalTranslationMaxAcc(context, request, response); }));}
    void SetMessageAllocatorFor_GetCartesianMechanicalTranslationMaxAcc(
        ::grpc::MessageAllocator< ::google::protobuf::Empty, ::controller::GetCartesianParamsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(24);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::controller::GetCartesianParamsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetCartesianMechanicalTranslationMaxAcc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCartesianMechanicalTranslationMaxAcc(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetCartesianParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetCartesianMechanicalTranslationMaxAcc(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetCartesianParamsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetCartesianMechanicalRotationMaxVel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetCartesianMechanicalRotationMaxVel() {
      ::grpc::Service::MarkMethodCallback(25,
          new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::controller::GetCartesianParamsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::google::protobuf::Empty* request, ::controller::GetCartesianParamsResponse* response) { return this->GetCartesianMechanicalRotationMaxVel(context, request, response); }));}
    void SetMessageAllocatorFor_GetCartesianMechanicalRotationMaxVel(
        ::grpc::MessageAllocator< ::google::protobuf::Empty, ::controller::GetCartesianParamsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(25);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::controller::GetCartesianParamsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetCartesianMechanicalRotationMaxVel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCartesianMechanicalRotationMaxVel(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetCartesianParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetCartesianMechanicalRotationMaxVel(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetCartesianParamsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetCartesianMechanicalRotationMaxAcc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetCartesianMechanicalRotationMaxAcc() {
      ::grpc::Service::MarkMethodCallback(26,
          new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::controller::GetCartesianParamsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::google::protobuf::Empty* request, ::controller::GetCartesianParamsResponse* response) { return this->GetCartesianMechanicalRotationMaxAcc(context, request, response); }));}
    void SetMessageAllocatorFor_GetCartesianMechanicalRotationMaxAcc(
        ::grpc::MessageAllocator< ::google::protobuf::Empty, ::controller::GetCartesianParamsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(26);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::controller::GetCartesianParamsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetCartesianMechanicalRotationMaxAcc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCartesianMechanicalRotationMaxAcc(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetCartesianParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetCartesianMechanicalRotationMaxAcc(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetCartesianParamsResponse* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_SetJointSoftLimit<WithCallbackMethod_SetJointMaxVel<WithCallbackMethod_SetJointMaxAcc<WithCallbackMethod_SetCartesianTranslationMaxVel<WithCallbackMethod_SetCartesianTranslationMaxAcc<WithCallbackMethod_SetCartesianRotationMaxVel<WithCallbackMethod_SetCartesianRotationMaxAcc<WithCallbackMethod_SetTcpOffset<WithCallbackMethod_SetTcpPayload<WithCallbackMethod_GetJointSoftLimit<WithCallbackMethod_GetJointMaxVel<WithCallbackMethod_GetJointMaxAcc<WithCallbackMethod_GetCartesianTranslationMaxVel<WithCallbackMethod_GetCartesianTranslationMaxAcc<WithCallbackMethod_GetCartesianRotationMaxVel<WithCallbackMethod_GetCartesianRotationMaxAcc<WithCallbackMethod_GetTcpOffset<WithCallbackMethod_GetTcpPayload<WithCallbackMethod_ForwardKinematics<WithCallbackMethod_InverseKinematics<WithCallbackMethod_GetJointMechanicalLimit<WithCallbackMethod_GetJointMechanicalMaxVel<WithCallbackMethod_GetJointMechanicalMaxAcc<WithCallbackMethod_GetCartesianMechanicalTranslationMaxVel<WithCallbackMethod_GetCartesianMechanicalTranslationMaxAcc<WithCallbackMethod_GetCartesianMechanicalRotationMaxVel<WithCallbackMethod_GetCartesianMechanicalRotationMaxAcc<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_SetJointSoftLimit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetJointSoftLimit() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_SetJointSoftLimit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetJointSoftLimit(::grpc::ServerContext* /*context*/, const ::controller::SetJointParamsRequest* /*request*/, ::controller::SetParamResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetJointMaxVel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetJointMaxVel() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_SetJointMaxVel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetJointMaxVel(::grpc::ServerContext* /*context*/, const ::controller::SetJointParamsRequest* /*request*/, ::controller::SetParamResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetJointMaxAcc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetJointMaxAcc() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_SetJointMaxAcc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetJointMaxAcc(::grpc::ServerContext* /*context*/, const ::controller::SetJointParamsRequest* /*request*/, ::controller::SetParamResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetCartesianTranslationMaxVel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetCartesianTranslationMaxVel() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_SetCartesianTranslationMaxVel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCartesianTranslationMaxVel(::grpc::ServerContext* /*context*/, const ::controller::SetCartesianParamsRequest* /*request*/, ::controller::SetParamResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetCartesianTranslationMaxAcc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetCartesianTranslationMaxAcc() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_SetCartesianTranslationMaxAcc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCartesianTranslationMaxAcc(::grpc::ServerContext* /*context*/, const ::controller::SetCartesianParamsRequest* /*request*/, ::controller::SetParamResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetCartesianRotationMaxVel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetCartesianRotationMaxVel() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_SetCartesianRotationMaxVel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCartesianRotationMaxVel(::grpc::ServerContext* /*context*/, const ::controller::SetCartesianParamsRequest* /*request*/, ::controller::SetParamResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetCartesianRotationMaxAcc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetCartesianRotationMaxAcc() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_SetCartesianRotationMaxAcc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCartesianRotationMaxAcc(::grpc::ServerContext* /*context*/, const ::controller::SetCartesianParamsRequest* /*request*/, ::controller::SetParamResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetTcpOffset : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetTcpOffset() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_SetTcpOffset() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetTcpOffset(::grpc::ServerContext* /*context*/, const ::controller::SetTcpOffsetParamsRequest* /*request*/, ::controller::SetParamResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetTcpPayload : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetTcpPayload() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_SetTcpPayload() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetTcpPayload(::grpc::ServerContext* /*context*/, const ::controller::SetTcpPayloadParamsRequest* /*request*/, ::controller::SetParamResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetJointSoftLimit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetJointSoftLimit() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_GetJointSoftLimit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetJointSoftLimit(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetJointParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetJointMaxVel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetJointMaxVel() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_GetJointMaxVel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetJointMaxVel(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetJointParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetJointMaxAcc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetJointMaxAcc() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_GetJointMaxAcc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetJointMaxAcc(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetJointParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetCartesianTranslationMaxVel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetCartesianTranslationMaxVel() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_GetCartesianTranslationMaxVel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCartesianTranslationMaxVel(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetCartesianParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetCartesianTranslationMaxAcc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetCartesianTranslationMaxAcc() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_GetCartesianTranslationMaxAcc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCartesianTranslationMaxAcc(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetCartesianParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetCartesianRotationMaxVel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetCartesianRotationMaxVel() {
      ::grpc::Service::MarkMethodGeneric(14);
    }
    ~WithGenericMethod_GetCartesianRotationMaxVel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCartesianRotationMaxVel(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetCartesianParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetCartesianRotationMaxAcc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetCartesianRotationMaxAcc() {
      ::grpc::Service::MarkMethodGeneric(15);
    }
    ~WithGenericMethod_GetCartesianRotationMaxAcc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCartesianRotationMaxAcc(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetCartesianParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetTcpOffset : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetTcpOffset() {
      ::grpc::Service::MarkMethodGeneric(16);
    }
    ~WithGenericMethod_GetTcpOffset() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTcpOffset(::grpc::ServerContext* /*context*/, const ::controller::GetTcpOffsetRequest* /*request*/, ::controller::GetTcpOffsetResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetTcpPayload : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetTcpPayload() {
      ::grpc::Service::MarkMethodGeneric(17);
    }
    ~WithGenericMethod_GetTcpPayload() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTcpPayload(::grpc::ServerContext* /*context*/, const ::controller::GetTcpPayloadRequest* /*request*/, ::controller::GetTcpPayloadResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ForwardKinematics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ForwardKinematics() {
      ::grpc::Service::MarkMethodGeneric(18);
    }
    ~WithGenericMethod_ForwardKinematics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ForwardKinematics(::grpc::ServerContext* /*context*/, const ::controller::ForwardKinematicsRequest* /*request*/, ::controller::ForwardKinematicsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_InverseKinematics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_InverseKinematics() {
      ::grpc::Service::MarkMethodGeneric(19);
    }
    ~WithGenericMethod_InverseKinematics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status InverseKinematics(::grpc::ServerContext* /*context*/, const ::controller::InverseKinematicsRequest* /*request*/, ::controller::InverseKinematicsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetJointMechanicalLimit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetJointMechanicalLimit() {
      ::grpc::Service::MarkMethodGeneric(20);
    }
    ~WithGenericMethod_GetJointMechanicalLimit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetJointMechanicalLimit(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetJointParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetJointMechanicalMaxVel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetJointMechanicalMaxVel() {
      ::grpc::Service::MarkMethodGeneric(21);
    }
    ~WithGenericMethod_GetJointMechanicalMaxVel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetJointMechanicalMaxVel(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetJointParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetJointMechanicalMaxAcc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetJointMechanicalMaxAcc() {
      ::grpc::Service::MarkMethodGeneric(22);
    }
    ~WithGenericMethod_GetJointMechanicalMaxAcc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetJointMechanicalMaxAcc(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetJointParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetCartesianMechanicalTranslationMaxVel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetCartesianMechanicalTranslationMaxVel() {
      ::grpc::Service::MarkMethodGeneric(23);
    }
    ~WithGenericMethod_GetCartesianMechanicalTranslationMaxVel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCartesianMechanicalTranslationMaxVel(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetCartesianParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetCartesianMechanicalTranslationMaxAcc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetCartesianMechanicalTranslationMaxAcc() {
      ::grpc::Service::MarkMethodGeneric(24);
    }
    ~WithGenericMethod_GetCartesianMechanicalTranslationMaxAcc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCartesianMechanicalTranslationMaxAcc(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetCartesianParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetCartesianMechanicalRotationMaxVel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetCartesianMechanicalRotationMaxVel() {
      ::grpc::Service::MarkMethodGeneric(25);
    }
    ~WithGenericMethod_GetCartesianMechanicalRotationMaxVel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCartesianMechanicalRotationMaxVel(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetCartesianParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetCartesianMechanicalRotationMaxAcc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetCartesianMechanicalRotationMaxAcc() {
      ::grpc::Service::MarkMethodGeneric(26);
    }
    ~WithGenericMethod_GetCartesianMechanicalRotationMaxAcc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCartesianMechanicalRotationMaxAcc(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetCartesianParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetJointSoftLimit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetJointSoftLimit() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_SetJointSoftLimit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetJointSoftLimit(::grpc::ServerContext* /*context*/, const ::controller::SetJointParamsRequest* /*request*/, ::controller::SetParamResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetJointSoftLimit(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetJointMaxVel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetJointMaxVel() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_SetJointMaxVel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetJointMaxVel(::grpc::ServerContext* /*context*/, const ::controller::SetJointParamsRequest* /*request*/, ::controller::SetParamResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetJointMaxVel(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetJointMaxAcc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetJointMaxAcc() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_SetJointMaxAcc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetJointMaxAcc(::grpc::ServerContext* /*context*/, const ::controller::SetJointParamsRequest* /*request*/, ::controller::SetParamResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetJointMaxAcc(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetCartesianTranslationMaxVel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetCartesianTranslationMaxVel() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_SetCartesianTranslationMaxVel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCartesianTranslationMaxVel(::grpc::ServerContext* /*context*/, const ::controller::SetCartesianParamsRequest* /*request*/, ::controller::SetParamResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetCartesianTranslationMaxVel(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetCartesianTranslationMaxAcc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetCartesianTranslationMaxAcc() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_SetCartesianTranslationMaxAcc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCartesianTranslationMaxAcc(::grpc::ServerContext* /*context*/, const ::controller::SetCartesianParamsRequest* /*request*/, ::controller::SetParamResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetCartesianTranslationMaxAcc(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetCartesianRotationMaxVel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetCartesianRotationMaxVel() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_SetCartesianRotationMaxVel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCartesianRotationMaxVel(::grpc::ServerContext* /*context*/, const ::controller::SetCartesianParamsRequest* /*request*/, ::controller::SetParamResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetCartesianRotationMaxVel(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetCartesianRotationMaxAcc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetCartesianRotationMaxAcc() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_SetCartesianRotationMaxAcc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCartesianRotationMaxAcc(::grpc::ServerContext* /*context*/, const ::controller::SetCartesianParamsRequest* /*request*/, ::controller::SetParamResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetCartesianRotationMaxAcc(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetTcpOffset : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetTcpOffset() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_SetTcpOffset() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetTcpOffset(::grpc::ServerContext* /*context*/, const ::controller::SetTcpOffsetParamsRequest* /*request*/, ::controller::SetParamResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetTcpOffset(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetTcpPayload : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetTcpPayload() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_SetTcpPayload() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetTcpPayload(::grpc::ServerContext* /*context*/, const ::controller::SetTcpPayloadParamsRequest* /*request*/, ::controller::SetParamResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetTcpPayload(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetJointSoftLimit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetJointSoftLimit() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_GetJointSoftLimit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetJointSoftLimit(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetJointParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetJointSoftLimit(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetJointMaxVel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetJointMaxVel() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_GetJointMaxVel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetJointMaxVel(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetJointParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetJointMaxVel(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetJointMaxAcc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetJointMaxAcc() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_GetJointMaxAcc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetJointMaxAcc(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetJointParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetJointMaxAcc(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetCartesianTranslationMaxVel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetCartesianTranslationMaxVel() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_GetCartesianTranslationMaxVel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCartesianTranslationMaxVel(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetCartesianParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetCartesianTranslationMaxVel(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetCartesianTranslationMaxAcc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetCartesianTranslationMaxAcc() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_GetCartesianTranslationMaxAcc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCartesianTranslationMaxAcc(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetCartesianParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetCartesianTranslationMaxAcc(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetCartesianRotationMaxVel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetCartesianRotationMaxVel() {
      ::grpc::Service::MarkMethodRaw(14);
    }
    ~WithRawMethod_GetCartesianRotationMaxVel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCartesianRotationMaxVel(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetCartesianParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetCartesianRotationMaxVel(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetCartesianRotationMaxAcc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetCartesianRotationMaxAcc() {
      ::grpc::Service::MarkMethodRaw(15);
    }
    ~WithRawMethod_GetCartesianRotationMaxAcc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCartesianRotationMaxAcc(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetCartesianParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetCartesianRotationMaxAcc(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetTcpOffset : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetTcpOffset() {
      ::grpc::Service::MarkMethodRaw(16);
    }
    ~WithRawMethod_GetTcpOffset() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTcpOffset(::grpc::ServerContext* /*context*/, const ::controller::GetTcpOffsetRequest* /*request*/, ::controller::GetTcpOffsetResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetTcpOffset(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetTcpPayload : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetTcpPayload() {
      ::grpc::Service::MarkMethodRaw(17);
    }
    ~WithRawMethod_GetTcpPayload() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTcpPayload(::grpc::ServerContext* /*context*/, const ::controller::GetTcpPayloadRequest* /*request*/, ::controller::GetTcpPayloadResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetTcpPayload(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ForwardKinematics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ForwardKinematics() {
      ::grpc::Service::MarkMethodRaw(18);
    }
    ~WithRawMethod_ForwardKinematics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ForwardKinematics(::grpc::ServerContext* /*context*/, const ::controller::ForwardKinematicsRequest* /*request*/, ::controller::ForwardKinematicsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestForwardKinematics(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_InverseKinematics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_InverseKinematics() {
      ::grpc::Service::MarkMethodRaw(19);
    }
    ~WithRawMethod_InverseKinematics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status InverseKinematics(::grpc::ServerContext* /*context*/, const ::controller::InverseKinematicsRequest* /*request*/, ::controller::InverseKinematicsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestInverseKinematics(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetJointMechanicalLimit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetJointMechanicalLimit() {
      ::grpc::Service::MarkMethodRaw(20);
    }
    ~WithRawMethod_GetJointMechanicalLimit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetJointMechanicalLimit(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetJointParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetJointMechanicalLimit(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetJointMechanicalMaxVel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetJointMechanicalMaxVel() {
      ::grpc::Service::MarkMethodRaw(21);
    }
    ~WithRawMethod_GetJointMechanicalMaxVel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetJointMechanicalMaxVel(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetJointParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetJointMechanicalMaxVel(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetJointMechanicalMaxAcc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetJointMechanicalMaxAcc() {
      ::grpc::Service::MarkMethodRaw(22);
    }
    ~WithRawMethod_GetJointMechanicalMaxAcc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetJointMechanicalMaxAcc(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetJointParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetJointMechanicalMaxAcc(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(22, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetCartesianMechanicalTranslationMaxVel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetCartesianMechanicalTranslationMaxVel() {
      ::grpc::Service::MarkMethodRaw(23);
    }
    ~WithRawMethod_GetCartesianMechanicalTranslationMaxVel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCartesianMechanicalTranslationMaxVel(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetCartesianParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetCartesianMechanicalTranslationMaxVel(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(23, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetCartesianMechanicalTranslationMaxAcc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetCartesianMechanicalTranslationMaxAcc() {
      ::grpc::Service::MarkMethodRaw(24);
    }
    ~WithRawMethod_GetCartesianMechanicalTranslationMaxAcc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCartesianMechanicalTranslationMaxAcc(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetCartesianParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetCartesianMechanicalTranslationMaxAcc(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(24, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetCartesianMechanicalRotationMaxVel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetCartesianMechanicalRotationMaxVel() {
      ::grpc::Service::MarkMethodRaw(25);
    }
    ~WithRawMethod_GetCartesianMechanicalRotationMaxVel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCartesianMechanicalRotationMaxVel(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetCartesianParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetCartesianMechanicalRotationMaxVel(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(25, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetCartesianMechanicalRotationMaxAcc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetCartesianMechanicalRotationMaxAcc() {
      ::grpc::Service::MarkMethodRaw(26);
    }
    ~WithRawMethod_GetCartesianMechanicalRotationMaxAcc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCartesianMechanicalRotationMaxAcc(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetCartesianParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetCartesianMechanicalRotationMaxAcc(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(26, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetJointSoftLimit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetJointSoftLimit() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetJointSoftLimit(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetJointSoftLimit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetJointSoftLimit(::grpc::ServerContext* /*context*/, const ::controller::SetJointParamsRequest* /*request*/, ::controller::SetParamResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetJointSoftLimit(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetJointMaxVel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetJointMaxVel() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetJointMaxVel(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetJointMaxVel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetJointMaxVel(::grpc::ServerContext* /*context*/, const ::controller::SetJointParamsRequest* /*request*/, ::controller::SetParamResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetJointMaxVel(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetJointMaxAcc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetJointMaxAcc() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetJointMaxAcc(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetJointMaxAcc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetJointMaxAcc(::grpc::ServerContext* /*context*/, const ::controller::SetJointParamsRequest* /*request*/, ::controller::SetParamResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetJointMaxAcc(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetCartesianTranslationMaxVel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetCartesianTranslationMaxVel() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetCartesianTranslationMaxVel(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetCartesianTranslationMaxVel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCartesianTranslationMaxVel(::grpc::ServerContext* /*context*/, const ::controller::SetCartesianParamsRequest* /*request*/, ::controller::SetParamResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetCartesianTranslationMaxVel(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetCartesianTranslationMaxAcc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetCartesianTranslationMaxAcc() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetCartesianTranslationMaxAcc(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetCartesianTranslationMaxAcc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCartesianTranslationMaxAcc(::grpc::ServerContext* /*context*/, const ::controller::SetCartesianParamsRequest* /*request*/, ::controller::SetParamResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetCartesianTranslationMaxAcc(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetCartesianRotationMaxVel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetCartesianRotationMaxVel() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetCartesianRotationMaxVel(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetCartesianRotationMaxVel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCartesianRotationMaxVel(::grpc::ServerContext* /*context*/, const ::controller::SetCartesianParamsRequest* /*request*/, ::controller::SetParamResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetCartesianRotationMaxVel(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetCartesianRotationMaxAcc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetCartesianRotationMaxAcc() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetCartesianRotationMaxAcc(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetCartesianRotationMaxAcc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCartesianRotationMaxAcc(::grpc::ServerContext* /*context*/, const ::controller::SetCartesianParamsRequest* /*request*/, ::controller::SetParamResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetCartesianRotationMaxAcc(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetTcpOffset : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetTcpOffset() {
      ::grpc::Service::MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetTcpOffset(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetTcpOffset() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetTcpOffset(::grpc::ServerContext* /*context*/, const ::controller::SetTcpOffsetParamsRequest* /*request*/, ::controller::SetParamResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetTcpOffset(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetTcpPayload : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetTcpPayload() {
      ::grpc::Service::MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetTcpPayload(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetTcpPayload() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetTcpPayload(::grpc::ServerContext* /*context*/, const ::controller::SetTcpPayloadParamsRequest* /*request*/, ::controller::SetParamResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetTcpPayload(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetJointSoftLimit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetJointSoftLimit() {
      ::grpc::Service::MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetJointSoftLimit(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetJointSoftLimit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetJointSoftLimit(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetJointParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetJointSoftLimit(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetJointMaxVel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetJointMaxVel() {
      ::grpc::Service::MarkMethodRawCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetJointMaxVel(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetJointMaxVel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetJointMaxVel(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetJointParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetJointMaxVel(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetJointMaxAcc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetJointMaxAcc() {
      ::grpc::Service::MarkMethodRawCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetJointMaxAcc(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetJointMaxAcc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetJointMaxAcc(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetJointParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetJointMaxAcc(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetCartesianTranslationMaxVel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetCartesianTranslationMaxVel() {
      ::grpc::Service::MarkMethodRawCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetCartesianTranslationMaxVel(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetCartesianTranslationMaxVel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCartesianTranslationMaxVel(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetCartesianParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetCartesianTranslationMaxVel(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetCartesianTranslationMaxAcc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetCartesianTranslationMaxAcc() {
      ::grpc::Service::MarkMethodRawCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetCartesianTranslationMaxAcc(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetCartesianTranslationMaxAcc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCartesianTranslationMaxAcc(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetCartesianParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetCartesianTranslationMaxAcc(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetCartesianRotationMaxVel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetCartesianRotationMaxVel() {
      ::grpc::Service::MarkMethodRawCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetCartesianRotationMaxVel(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetCartesianRotationMaxVel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCartesianRotationMaxVel(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetCartesianParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetCartesianRotationMaxVel(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetCartesianRotationMaxAcc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetCartesianRotationMaxAcc() {
      ::grpc::Service::MarkMethodRawCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetCartesianRotationMaxAcc(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetCartesianRotationMaxAcc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCartesianRotationMaxAcc(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetCartesianParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetCartesianRotationMaxAcc(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetTcpOffset : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetTcpOffset() {
      ::grpc::Service::MarkMethodRawCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetTcpOffset(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetTcpOffset() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTcpOffset(::grpc::ServerContext* /*context*/, const ::controller::GetTcpOffsetRequest* /*request*/, ::controller::GetTcpOffsetResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetTcpOffset(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetTcpPayload : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetTcpPayload() {
      ::grpc::Service::MarkMethodRawCallback(17,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetTcpPayload(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetTcpPayload() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTcpPayload(::grpc::ServerContext* /*context*/, const ::controller::GetTcpPayloadRequest* /*request*/, ::controller::GetTcpPayloadResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetTcpPayload(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ForwardKinematics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ForwardKinematics() {
      ::grpc::Service::MarkMethodRawCallback(18,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ForwardKinematics(context, request, response); }));
    }
    ~WithRawCallbackMethod_ForwardKinematics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ForwardKinematics(::grpc::ServerContext* /*context*/, const ::controller::ForwardKinematicsRequest* /*request*/, ::controller::ForwardKinematicsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ForwardKinematics(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_InverseKinematics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_InverseKinematics() {
      ::grpc::Service::MarkMethodRawCallback(19,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->InverseKinematics(context, request, response); }));
    }
    ~WithRawCallbackMethod_InverseKinematics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status InverseKinematics(::grpc::ServerContext* /*context*/, const ::controller::InverseKinematicsRequest* /*request*/, ::controller::InverseKinematicsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* InverseKinematics(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetJointMechanicalLimit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetJointMechanicalLimit() {
      ::grpc::Service::MarkMethodRawCallback(20,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetJointMechanicalLimit(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetJointMechanicalLimit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetJointMechanicalLimit(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetJointParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetJointMechanicalLimit(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetJointMechanicalMaxVel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetJointMechanicalMaxVel() {
      ::grpc::Service::MarkMethodRawCallback(21,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetJointMechanicalMaxVel(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetJointMechanicalMaxVel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetJointMechanicalMaxVel(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetJointParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetJointMechanicalMaxVel(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetJointMechanicalMaxAcc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetJointMechanicalMaxAcc() {
      ::grpc::Service::MarkMethodRawCallback(22,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetJointMechanicalMaxAcc(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetJointMechanicalMaxAcc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetJointMechanicalMaxAcc(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetJointParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetJointMechanicalMaxAcc(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetCartesianMechanicalTranslationMaxVel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetCartesianMechanicalTranslationMaxVel() {
      ::grpc::Service::MarkMethodRawCallback(23,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetCartesianMechanicalTranslationMaxVel(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetCartesianMechanicalTranslationMaxVel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCartesianMechanicalTranslationMaxVel(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetCartesianParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetCartesianMechanicalTranslationMaxVel(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetCartesianMechanicalTranslationMaxAcc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetCartesianMechanicalTranslationMaxAcc() {
      ::grpc::Service::MarkMethodRawCallback(24,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetCartesianMechanicalTranslationMaxAcc(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetCartesianMechanicalTranslationMaxAcc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCartesianMechanicalTranslationMaxAcc(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetCartesianParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetCartesianMechanicalTranslationMaxAcc(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetCartesianMechanicalRotationMaxVel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetCartesianMechanicalRotationMaxVel() {
      ::grpc::Service::MarkMethodRawCallback(25,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetCartesianMechanicalRotationMaxVel(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetCartesianMechanicalRotationMaxVel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCartesianMechanicalRotationMaxVel(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetCartesianParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetCartesianMechanicalRotationMaxVel(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetCartesianMechanicalRotationMaxAcc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetCartesianMechanicalRotationMaxAcc() {
      ::grpc::Service::MarkMethodRawCallback(26,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetCartesianMechanicalRotationMaxAcc(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetCartesianMechanicalRotationMaxAcc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCartesianMechanicalRotationMaxAcc(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetCartesianParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetCartesianMechanicalRotationMaxAcc(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetJointSoftLimit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetJointSoftLimit() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::controller::SetJointParamsRequest, ::controller::SetParamResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::controller::SetJointParamsRequest, ::controller::SetParamResponse>* streamer) {
                       return this->StreamedSetJointSoftLimit(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetJointSoftLimit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetJointSoftLimit(::grpc::ServerContext* /*context*/, const ::controller::SetJointParamsRequest* /*request*/, ::controller::SetParamResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetJointSoftLimit(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::controller::SetJointParamsRequest,::controller::SetParamResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetJointMaxVel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetJointMaxVel() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::controller::SetJointParamsRequest, ::controller::SetParamResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::controller::SetJointParamsRequest, ::controller::SetParamResponse>* streamer) {
                       return this->StreamedSetJointMaxVel(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetJointMaxVel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetJointMaxVel(::grpc::ServerContext* /*context*/, const ::controller::SetJointParamsRequest* /*request*/, ::controller::SetParamResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetJointMaxVel(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::controller::SetJointParamsRequest,::controller::SetParamResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetJointMaxAcc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetJointMaxAcc() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::controller::SetJointParamsRequest, ::controller::SetParamResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::controller::SetJointParamsRequest, ::controller::SetParamResponse>* streamer) {
                       return this->StreamedSetJointMaxAcc(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetJointMaxAcc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetJointMaxAcc(::grpc::ServerContext* /*context*/, const ::controller::SetJointParamsRequest* /*request*/, ::controller::SetParamResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetJointMaxAcc(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::controller::SetJointParamsRequest,::controller::SetParamResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetCartesianTranslationMaxVel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetCartesianTranslationMaxVel() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::controller::SetCartesianParamsRequest, ::controller::SetParamResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::controller::SetCartesianParamsRequest, ::controller::SetParamResponse>* streamer) {
                       return this->StreamedSetCartesianTranslationMaxVel(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetCartesianTranslationMaxVel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetCartesianTranslationMaxVel(::grpc::ServerContext* /*context*/, const ::controller::SetCartesianParamsRequest* /*request*/, ::controller::SetParamResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetCartesianTranslationMaxVel(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::controller::SetCartesianParamsRequest,::controller::SetParamResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetCartesianTranslationMaxAcc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetCartesianTranslationMaxAcc() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::controller::SetCartesianParamsRequest, ::controller::SetParamResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::controller::SetCartesianParamsRequest, ::controller::SetParamResponse>* streamer) {
                       return this->StreamedSetCartesianTranslationMaxAcc(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetCartesianTranslationMaxAcc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetCartesianTranslationMaxAcc(::grpc::ServerContext* /*context*/, const ::controller::SetCartesianParamsRequest* /*request*/, ::controller::SetParamResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetCartesianTranslationMaxAcc(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::controller::SetCartesianParamsRequest,::controller::SetParamResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetCartesianRotationMaxVel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetCartesianRotationMaxVel() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::controller::SetCartesianParamsRequest, ::controller::SetParamResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::controller::SetCartesianParamsRequest, ::controller::SetParamResponse>* streamer) {
                       return this->StreamedSetCartesianRotationMaxVel(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetCartesianRotationMaxVel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetCartesianRotationMaxVel(::grpc::ServerContext* /*context*/, const ::controller::SetCartesianParamsRequest* /*request*/, ::controller::SetParamResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetCartesianRotationMaxVel(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::controller::SetCartesianParamsRequest,::controller::SetParamResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetCartesianRotationMaxAcc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetCartesianRotationMaxAcc() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::controller::SetCartesianParamsRequest, ::controller::SetParamResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::controller::SetCartesianParamsRequest, ::controller::SetParamResponse>* streamer) {
                       return this->StreamedSetCartesianRotationMaxAcc(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetCartesianRotationMaxAcc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetCartesianRotationMaxAcc(::grpc::ServerContext* /*context*/, const ::controller::SetCartesianParamsRequest* /*request*/, ::controller::SetParamResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetCartesianRotationMaxAcc(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::controller::SetCartesianParamsRequest,::controller::SetParamResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetTcpOffset : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetTcpOffset() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::controller::SetTcpOffsetParamsRequest, ::controller::SetParamResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::controller::SetTcpOffsetParamsRequest, ::controller::SetParamResponse>* streamer) {
                       return this->StreamedSetTcpOffset(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetTcpOffset() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetTcpOffset(::grpc::ServerContext* /*context*/, const ::controller::SetTcpOffsetParamsRequest* /*request*/, ::controller::SetParamResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetTcpOffset(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::controller::SetTcpOffsetParamsRequest,::controller::SetParamResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetTcpPayload : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetTcpPayload() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::controller::SetTcpPayloadParamsRequest, ::controller::SetParamResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::controller::SetTcpPayloadParamsRequest, ::controller::SetParamResponse>* streamer) {
                       return this->StreamedSetTcpPayload(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetTcpPayload() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetTcpPayload(::grpc::ServerContext* /*context*/, const ::controller::SetTcpPayloadParamsRequest* /*request*/, ::controller::SetParamResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetTcpPayload(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::controller::SetTcpPayloadParamsRequest,::controller::SetParamResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetJointSoftLimit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetJointSoftLimit() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::controller::GetJointParamsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::controller::GetJointParamsResponse>* streamer) {
                       return this->StreamedGetJointSoftLimit(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetJointSoftLimit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetJointSoftLimit(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetJointParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetJointSoftLimit(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::controller::GetJointParamsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetJointMaxVel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetJointMaxVel() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::controller::GetJointParamsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::controller::GetJointParamsResponse>* streamer) {
                       return this->StreamedGetJointMaxVel(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetJointMaxVel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetJointMaxVel(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetJointParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetJointMaxVel(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::controller::GetJointParamsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetJointMaxAcc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetJointMaxAcc() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::controller::GetJointParamsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::controller::GetJointParamsResponse>* streamer) {
                       return this->StreamedGetJointMaxAcc(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetJointMaxAcc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetJointMaxAcc(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetJointParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetJointMaxAcc(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::controller::GetJointParamsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetCartesianTranslationMaxVel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetCartesianTranslationMaxVel() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::controller::GetCartesianParamsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::controller::GetCartesianParamsResponse>* streamer) {
                       return this->StreamedGetCartesianTranslationMaxVel(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetCartesianTranslationMaxVel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetCartesianTranslationMaxVel(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetCartesianParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetCartesianTranslationMaxVel(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::controller::GetCartesianParamsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetCartesianTranslationMaxAcc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetCartesianTranslationMaxAcc() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::controller::GetCartesianParamsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::controller::GetCartesianParamsResponse>* streamer) {
                       return this->StreamedGetCartesianTranslationMaxAcc(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetCartesianTranslationMaxAcc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetCartesianTranslationMaxAcc(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetCartesianParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetCartesianTranslationMaxAcc(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::controller::GetCartesianParamsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetCartesianRotationMaxVel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetCartesianRotationMaxVel() {
      ::grpc::Service::MarkMethodStreamed(14,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::controller::GetCartesianParamsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::controller::GetCartesianParamsResponse>* streamer) {
                       return this->StreamedGetCartesianRotationMaxVel(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetCartesianRotationMaxVel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetCartesianRotationMaxVel(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetCartesianParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetCartesianRotationMaxVel(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::controller::GetCartesianParamsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetCartesianRotationMaxAcc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetCartesianRotationMaxAcc() {
      ::grpc::Service::MarkMethodStreamed(15,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::controller::GetCartesianParamsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::controller::GetCartesianParamsResponse>* streamer) {
                       return this->StreamedGetCartesianRotationMaxAcc(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetCartesianRotationMaxAcc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetCartesianRotationMaxAcc(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetCartesianParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetCartesianRotationMaxAcc(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::controller::GetCartesianParamsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetTcpOffset : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetTcpOffset() {
      ::grpc::Service::MarkMethodStreamed(16,
        new ::grpc::internal::StreamedUnaryHandler<
          ::controller::GetTcpOffsetRequest, ::controller::GetTcpOffsetResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::controller::GetTcpOffsetRequest, ::controller::GetTcpOffsetResponse>* streamer) {
                       return this->StreamedGetTcpOffset(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetTcpOffset() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetTcpOffset(::grpc::ServerContext* /*context*/, const ::controller::GetTcpOffsetRequest* /*request*/, ::controller::GetTcpOffsetResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetTcpOffset(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::controller::GetTcpOffsetRequest,::controller::GetTcpOffsetResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetTcpPayload : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetTcpPayload() {
      ::grpc::Service::MarkMethodStreamed(17,
        new ::grpc::internal::StreamedUnaryHandler<
          ::controller::GetTcpPayloadRequest, ::controller::GetTcpPayloadResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::controller::GetTcpPayloadRequest, ::controller::GetTcpPayloadResponse>* streamer) {
                       return this->StreamedGetTcpPayload(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetTcpPayload() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetTcpPayload(::grpc::ServerContext* /*context*/, const ::controller::GetTcpPayloadRequest* /*request*/, ::controller::GetTcpPayloadResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetTcpPayload(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::controller::GetTcpPayloadRequest,::controller::GetTcpPayloadResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ForwardKinematics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ForwardKinematics() {
      ::grpc::Service::MarkMethodStreamed(18,
        new ::grpc::internal::StreamedUnaryHandler<
          ::controller::ForwardKinematicsRequest, ::controller::ForwardKinematicsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::controller::ForwardKinematicsRequest, ::controller::ForwardKinematicsResponse>* streamer) {
                       return this->StreamedForwardKinematics(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ForwardKinematics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ForwardKinematics(::grpc::ServerContext* /*context*/, const ::controller::ForwardKinematicsRequest* /*request*/, ::controller::ForwardKinematicsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedForwardKinematics(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::controller::ForwardKinematicsRequest,::controller::ForwardKinematicsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_InverseKinematics : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_InverseKinematics() {
      ::grpc::Service::MarkMethodStreamed(19,
        new ::grpc::internal::StreamedUnaryHandler<
          ::controller::InverseKinematicsRequest, ::controller::InverseKinematicsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::controller::InverseKinematicsRequest, ::controller::InverseKinematicsResponse>* streamer) {
                       return this->StreamedInverseKinematics(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_InverseKinematics() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status InverseKinematics(::grpc::ServerContext* /*context*/, const ::controller::InverseKinematicsRequest* /*request*/, ::controller::InverseKinematicsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedInverseKinematics(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::controller::InverseKinematicsRequest,::controller::InverseKinematicsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetJointMechanicalLimit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetJointMechanicalLimit() {
      ::grpc::Service::MarkMethodStreamed(20,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::controller::GetJointParamsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::controller::GetJointParamsResponse>* streamer) {
                       return this->StreamedGetJointMechanicalLimit(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetJointMechanicalLimit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetJointMechanicalLimit(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetJointParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetJointMechanicalLimit(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::controller::GetJointParamsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetJointMechanicalMaxVel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetJointMechanicalMaxVel() {
      ::grpc::Service::MarkMethodStreamed(21,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::controller::GetJointParamsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::controller::GetJointParamsResponse>* streamer) {
                       return this->StreamedGetJointMechanicalMaxVel(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetJointMechanicalMaxVel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetJointMechanicalMaxVel(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetJointParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetJointMechanicalMaxVel(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::controller::GetJointParamsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetJointMechanicalMaxAcc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetJointMechanicalMaxAcc() {
      ::grpc::Service::MarkMethodStreamed(22,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::controller::GetJointParamsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::controller::GetJointParamsResponse>* streamer) {
                       return this->StreamedGetJointMechanicalMaxAcc(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetJointMechanicalMaxAcc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetJointMechanicalMaxAcc(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetJointParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetJointMechanicalMaxAcc(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::controller::GetJointParamsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetCartesianMechanicalTranslationMaxVel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetCartesianMechanicalTranslationMaxVel() {
      ::grpc::Service::MarkMethodStreamed(23,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::controller::GetCartesianParamsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::controller::GetCartesianParamsResponse>* streamer) {
                       return this->StreamedGetCartesianMechanicalTranslationMaxVel(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetCartesianMechanicalTranslationMaxVel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetCartesianMechanicalTranslationMaxVel(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetCartesianParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetCartesianMechanicalTranslationMaxVel(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::controller::GetCartesianParamsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetCartesianMechanicalTranslationMaxAcc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetCartesianMechanicalTranslationMaxAcc() {
      ::grpc::Service::MarkMethodStreamed(24,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::controller::GetCartesianParamsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::controller::GetCartesianParamsResponse>* streamer) {
                       return this->StreamedGetCartesianMechanicalTranslationMaxAcc(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetCartesianMechanicalTranslationMaxAcc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetCartesianMechanicalTranslationMaxAcc(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetCartesianParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetCartesianMechanicalTranslationMaxAcc(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::controller::GetCartesianParamsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetCartesianMechanicalRotationMaxVel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetCartesianMechanicalRotationMaxVel() {
      ::grpc::Service::MarkMethodStreamed(25,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::controller::GetCartesianParamsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::controller::GetCartesianParamsResponse>* streamer) {
                       return this->StreamedGetCartesianMechanicalRotationMaxVel(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetCartesianMechanicalRotationMaxVel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetCartesianMechanicalRotationMaxVel(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetCartesianParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetCartesianMechanicalRotationMaxVel(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::controller::GetCartesianParamsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetCartesianMechanicalRotationMaxAcc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetCartesianMechanicalRotationMaxAcc() {
      ::grpc::Service::MarkMethodStreamed(26,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::controller::GetCartesianParamsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::controller::GetCartesianParamsResponse>* streamer) {
                       return this->StreamedGetCartesianMechanicalRotationMaxAcc(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetCartesianMechanicalRotationMaxAcc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetCartesianMechanicalRotationMaxAcc(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::controller::GetCartesianParamsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetCartesianMechanicalRotationMaxAcc(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::controller::GetCartesianParamsResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_SetJointSoftLimit<WithStreamedUnaryMethod_SetJointMaxVel<WithStreamedUnaryMethod_SetJointMaxAcc<WithStreamedUnaryMethod_SetCartesianTranslationMaxVel<WithStreamedUnaryMethod_SetCartesianTranslationMaxAcc<WithStreamedUnaryMethod_SetCartesianRotationMaxVel<WithStreamedUnaryMethod_SetCartesianRotationMaxAcc<WithStreamedUnaryMethod_SetTcpOffset<WithStreamedUnaryMethod_SetTcpPayload<WithStreamedUnaryMethod_GetJointSoftLimit<WithStreamedUnaryMethod_GetJointMaxVel<WithStreamedUnaryMethod_GetJointMaxAcc<WithStreamedUnaryMethod_GetCartesianTranslationMaxVel<WithStreamedUnaryMethod_GetCartesianTranslationMaxAcc<WithStreamedUnaryMethod_GetCartesianRotationMaxVel<WithStreamedUnaryMethod_GetCartesianRotationMaxAcc<WithStreamedUnaryMethod_GetTcpOffset<WithStreamedUnaryMethod_GetTcpPayload<WithStreamedUnaryMethod_ForwardKinematics<WithStreamedUnaryMethod_InverseKinematics<WithStreamedUnaryMethod_GetJointMechanicalLimit<WithStreamedUnaryMethod_GetJointMechanicalMaxVel<WithStreamedUnaryMethod_GetJointMechanicalMaxAcc<WithStreamedUnaryMethod_GetCartesianMechanicalTranslationMaxVel<WithStreamedUnaryMethod_GetCartesianMechanicalTranslationMaxAcc<WithStreamedUnaryMethod_GetCartesianMechanicalRotationMaxVel<WithStreamedUnaryMethod_GetCartesianMechanicalRotationMaxAcc<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_SetJointSoftLimit<WithStreamedUnaryMethod_SetJointMaxVel<WithStreamedUnaryMethod_SetJointMaxAcc<WithStreamedUnaryMethod_SetCartesianTranslationMaxVel<WithStreamedUnaryMethod_SetCartesianTranslationMaxAcc<WithStreamedUnaryMethod_SetCartesianRotationMaxVel<WithStreamedUnaryMethod_SetCartesianRotationMaxAcc<WithStreamedUnaryMethod_SetTcpOffset<WithStreamedUnaryMethod_SetTcpPayload<WithStreamedUnaryMethod_GetJointSoftLimit<WithStreamedUnaryMethod_GetJointMaxVel<WithStreamedUnaryMethod_GetJointMaxAcc<WithStreamedUnaryMethod_GetCartesianTranslationMaxVel<WithStreamedUnaryMethod_GetCartesianTranslationMaxAcc<WithStreamedUnaryMethod_GetCartesianRotationMaxVel<WithStreamedUnaryMethod_GetCartesianRotationMaxAcc<WithStreamedUnaryMethod_GetTcpOffset<WithStreamedUnaryMethod_GetTcpPayload<WithStreamedUnaryMethod_ForwardKinematics<WithStreamedUnaryMethod_InverseKinematics<WithStreamedUnaryMethod_GetJointMechanicalLimit<WithStreamedUnaryMethod_GetJointMechanicalMaxVel<WithStreamedUnaryMethod_GetJointMechanicalMaxAcc<WithStreamedUnaryMethod_GetCartesianMechanicalTranslationMaxVel<WithStreamedUnaryMethod_GetCartesianMechanicalTranslationMaxAcc<WithStreamedUnaryMethod_GetCartesianMechanicalRotationMaxVel<WithStreamedUnaryMethod_GetCartesianMechanicalRotationMaxAcc<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > StreamedService;
};

}  // namespace controller


#include <grpcpp/ports_undef.inc>
#endif  // GRPC_params_5fservice_2eproto__INCLUDED
