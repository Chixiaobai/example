// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: Service.proto
#ifndef GRPC_Service_2eproto__INCLUDED
#define GRPC_Service_2eproto__INCLUDED

#include "Service.pb.h"

#include <functional>
#include <grpcpp/generic/async_generic_service.h>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/support/client_callback.h>
#include <grpcpp/client_context.h>
#include <grpcpp/completion_queue.h>
#include <grpcpp/support/message_allocator.h>
#include <grpcpp/support/method_handler.h>
#include <grpcpp/impl/proto_utils.h>
#include <grpcpp/impl/rpc_method.h>
#include <grpcpp/support/server_callback.h>
#include <grpcpp/impl/server_callback_handlers.h>
#include <grpcpp/server_context.h>
#include <grpcpp/impl/service_type.h>
#include <grpcpp/support/status.h>
#include <grpcpp/support/stub_options.h>
#include <grpcpp/support/sync_stream.h>
#include <grpcpp/ports_def.inc>

namespace H10WService {

// 设备控制服务 批量控制设备抱闸状态
class DeviceControlService final {
 public:
  static constexpr char const* service_full_name() {
    return "H10WService.DeviceControlService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status ControlBrakeStatus(::grpc::ClientContext* context, const ::H10WService::BrakeControlRequest& request, ::H10WService::BrakeControlResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::H10WService::BrakeControlResponse>> AsyncControlBrakeStatus(::grpc::ClientContext* context, const ::H10WService::BrakeControlRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::H10WService::BrakeControlResponse>>(AsyncControlBrakeStatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::H10WService::BrakeControlResponse>> PrepareAsyncControlBrakeStatus(::grpc::ClientContext* context, const ::H10WService::BrakeControlRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::H10WService::BrakeControlResponse>>(PrepareAsyncControlBrakeStatusRaw(context, request, cq));
    }
    virtual ::grpc::Status ControlPowerStatus(::grpc::ClientContext* context, const ::H10WService::PowerControlRequest& request, ::H10WService::PowerControlResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::H10WService::PowerControlResponse>> AsyncControlPowerStatus(::grpc::ClientContext* context, const ::H10WService::PowerControlRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::H10WService::PowerControlResponse>>(AsyncControlPowerStatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::H10WService::PowerControlResponse>> PrepareAsyncControlPowerStatus(::grpc::ClientContext* context, const ::H10WService::PowerControlRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::H10WService::PowerControlResponse>>(PrepareAsyncControlPowerStatusRaw(context, request, cq));
    }
    virtual ::grpc::Status GetTorqueOffset(::grpc::ClientContext* context, const ::H10WService::TorqueOffSetRequest& request, ::H10WService::TorqueOffSetResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::H10WService::TorqueOffSetResponse>> AsyncGetTorqueOffset(::grpc::ClientContext* context, const ::H10WService::TorqueOffSetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::H10WService::TorqueOffSetResponse>>(AsyncGetTorqueOffsetRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::H10WService::TorqueOffSetResponse>> PrepareAsyncGetTorqueOffset(::grpc::ClientContext* context, const ::H10WService::TorqueOffSetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::H10WService::TorqueOffSetResponse>>(PrepareAsyncGetTorqueOffsetRaw(context, request, cq));
    }
    virtual ::grpc::Status GetJointErrorCode(::grpc::ClientContext* context, const ::H10WService::GetErrorCodeRequest& request, ::H10WService::GetErrorCodeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::H10WService::GetErrorCodeResponse>> AsyncGetJointErrorCode(::grpc::ClientContext* context, const ::H10WService::GetErrorCodeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::H10WService::GetErrorCodeResponse>>(AsyncGetJointErrorCodeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::H10WService::GetErrorCodeResponse>> PrepareAsyncGetJointErrorCode(::grpc::ClientContext* context, const ::H10WService::GetErrorCodeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::H10WService::GetErrorCodeResponse>>(PrepareAsyncGetJointErrorCodeRaw(context, request, cq));
    }
    virtual ::grpc::Status CalibrationZero(::grpc::ClientContext* context, const ::H10WService::CalibrationRequest& request, ::H10WService::CalibrationResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::H10WService::CalibrationResponse>> AsyncCalibrationZero(::grpc::ClientContext* context, const ::H10WService::CalibrationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::H10WService::CalibrationResponse>>(AsyncCalibrationZeroRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::H10WService::CalibrationResponse>> PrepareAsyncCalibrationZero(::grpc::ClientContext* context, const ::H10WService::CalibrationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::H10WService::CalibrationResponse>>(PrepareAsyncCalibrationZeroRaw(context, request, cq));
    }
    virtual ::grpc::Status SaveParameter(::grpc::ClientContext* context, const ::H10WService::SaveParameterRequest& request, ::H10WService::SaveParameterResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::H10WService::SaveParameterResponse>> AsyncSaveParameter(::grpc::ClientContext* context, const ::H10WService::SaveParameterRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::H10WService::SaveParameterResponse>>(AsyncSaveParameterRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::H10WService::SaveParameterResponse>> PrepareAsyncSaveParameter(::grpc::ClientContext* context, const ::H10WService::SaveParameterRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::H10WService::SaveParameterResponse>>(PrepareAsyncSaveParameterRaw(context, request, cq));
    }
    virtual ::grpc::Status ClearError(::grpc::ClientContext* context, const ::H10WService::ClearErrorRequest& request, ::H10WService::ClearErrorResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::H10WService::ClearErrorResponse>> AsyncClearError(::grpc::ClientContext* context, const ::H10WService::ClearErrorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::H10WService::ClearErrorResponse>>(AsyncClearErrorRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::H10WService::ClearErrorResponse>> PrepareAsyncClearError(::grpc::ClientContext* context, const ::H10WService::ClearErrorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::H10WService::ClearErrorResponse>>(PrepareAsyncClearErrorRaw(context, request, cq));
    }
    virtual ::grpc::Status Calibration90Deg(::grpc::ClientContext* context, const ::H10WService::CalibrationRequest& request, ::H10WService::CalibrationResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::H10WService::CalibrationResponse>> AsyncCalibration90Deg(::grpc::ClientContext* context, const ::H10WService::CalibrationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::H10WService::CalibrationResponse>>(AsyncCalibration90DegRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::H10WService::CalibrationResponse>> PrepareAsyncCalibration90Deg(::grpc::ClientContext* context, const ::H10WService::CalibrationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::H10WService::CalibrationResponse>>(PrepareAsyncCalibration90DegRaw(context, request, cq));
    }
    virtual ::grpc::Status SetJointSoftLimit(::grpc::ClientContext* context, const ::H10WService::SetJointSoftLimitRequest& request, ::H10WService::SetJointSoftLimitResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::H10WService::SetJointSoftLimitResponse>> AsyncSetJointSoftLimit(::grpc::ClientContext* context, const ::H10WService::SetJointSoftLimitRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::H10WService::SetJointSoftLimitResponse>>(AsyncSetJointSoftLimitRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::H10WService::SetJointSoftLimitResponse>> PrepareAsyncSetJointSoftLimit(::grpc::ClientContext* context, const ::H10WService::SetJointSoftLimitRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::H10WService::SetJointSoftLimitResponse>>(PrepareAsyncSetJointSoftLimitRaw(context, request, cq));
    }
    virtual ::grpc::Status GetJointSoftLimit(::grpc::ClientContext* context, const ::H10WService::GetJointSoftLimitRequest& request, ::H10WService::GetJointSoftLimitResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::H10WService::GetJointSoftLimitResponse>> AsyncGetJointSoftLimit(::grpc::ClientContext* context, const ::H10WService::GetJointSoftLimitRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::H10WService::GetJointSoftLimitResponse>>(AsyncGetJointSoftLimitRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::H10WService::GetJointSoftLimitResponse>> PrepareAsyncGetJointSoftLimit(::grpc::ClientContext* context, const ::H10WService::GetJointSoftLimitRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::H10WService::GetJointSoftLimitResponse>>(PrepareAsyncGetJointSoftLimitRaw(context, request, cq));
    }
    virtual ::grpc::Status GetJointHardLimit(::grpc::ClientContext* context, const ::H10WService::GetJointHardLimitRequest& request, ::H10WService::GetJointHardLimitResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::H10WService::GetJointHardLimitResponse>> AsyncGetJointHardLimit(::grpc::ClientContext* context, const ::H10WService::GetJointHardLimitRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::H10WService::GetJointHardLimitResponse>>(AsyncGetJointHardLimitRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::H10WService::GetJointHardLimitResponse>> PrepareAsyncGetJointHardLimit(::grpc::ClientContext* context, const ::H10WService::GetJointHardLimitRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::H10WService::GetJointHardLimitResponse>>(PrepareAsyncGetJointHardLimitRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      virtual void ControlBrakeStatus(::grpc::ClientContext* context, const ::H10WService::BrakeControlRequest* request, ::H10WService::BrakeControlResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ControlBrakeStatus(::grpc::ClientContext* context, const ::H10WService::BrakeControlRequest* request, ::H10WService::BrakeControlResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void ControlPowerStatus(::grpc::ClientContext* context, const ::H10WService::PowerControlRequest* request, ::H10WService::PowerControlResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ControlPowerStatus(::grpc::ClientContext* context, const ::H10WService::PowerControlRequest* request, ::H10WService::PowerControlResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetTorqueOffset(::grpc::ClientContext* context, const ::H10WService::TorqueOffSetRequest* request, ::H10WService::TorqueOffSetResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetTorqueOffset(::grpc::ClientContext* context, const ::H10WService::TorqueOffSetRequest* request, ::H10WService::TorqueOffSetResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetJointErrorCode(::grpc::ClientContext* context, const ::H10WService::GetErrorCodeRequest* request, ::H10WService::GetErrorCodeResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetJointErrorCode(::grpc::ClientContext* context, const ::H10WService::GetErrorCodeRequest* request, ::H10WService::GetErrorCodeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void CalibrationZero(::grpc::ClientContext* context, const ::H10WService::CalibrationRequest* request, ::H10WService::CalibrationResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CalibrationZero(::grpc::ClientContext* context, const ::H10WService::CalibrationRequest* request, ::H10WService::CalibrationResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SaveParameter(::grpc::ClientContext* context, const ::H10WService::SaveParameterRequest* request, ::H10WService::SaveParameterResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SaveParameter(::grpc::ClientContext* context, const ::H10WService::SaveParameterRequest* request, ::H10WService::SaveParameterResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void ClearError(::grpc::ClientContext* context, const ::H10WService::ClearErrorRequest* request, ::H10WService::ClearErrorResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ClearError(::grpc::ClientContext* context, const ::H10WService::ClearErrorRequest* request, ::H10WService::ClearErrorResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void Calibration90Deg(::grpc::ClientContext* context, const ::H10WService::CalibrationRequest* request, ::H10WService::CalibrationResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Calibration90Deg(::grpc::ClientContext* context, const ::H10WService::CalibrationRequest* request, ::H10WService::CalibrationResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetJointSoftLimit(::grpc::ClientContext* context, const ::H10WService::SetJointSoftLimitRequest* request, ::H10WService::SetJointSoftLimitResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetJointSoftLimit(::grpc::ClientContext* context, const ::H10WService::SetJointSoftLimitRequest* request, ::H10WService::SetJointSoftLimitResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetJointSoftLimit(::grpc::ClientContext* context, const ::H10WService::GetJointSoftLimitRequest* request, ::H10WService::GetJointSoftLimitResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetJointSoftLimit(::grpc::ClientContext* context, const ::H10WService::GetJointSoftLimitRequest* request, ::H10WService::GetJointSoftLimitResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetJointHardLimit(::grpc::ClientContext* context, const ::H10WService::GetJointHardLimitRequest* request, ::H10WService::GetJointHardLimitResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetJointHardLimit(::grpc::ClientContext* context, const ::H10WService::GetJointHardLimitRequest* request, ::H10WService::GetJointHardLimitResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::H10WService::BrakeControlResponse>* AsyncControlBrakeStatusRaw(::grpc::ClientContext* context, const ::H10WService::BrakeControlRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::H10WService::BrakeControlResponse>* PrepareAsyncControlBrakeStatusRaw(::grpc::ClientContext* context, const ::H10WService::BrakeControlRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::H10WService::PowerControlResponse>* AsyncControlPowerStatusRaw(::grpc::ClientContext* context, const ::H10WService::PowerControlRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::H10WService::PowerControlResponse>* PrepareAsyncControlPowerStatusRaw(::grpc::ClientContext* context, const ::H10WService::PowerControlRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::H10WService::TorqueOffSetResponse>* AsyncGetTorqueOffsetRaw(::grpc::ClientContext* context, const ::H10WService::TorqueOffSetRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::H10WService::TorqueOffSetResponse>* PrepareAsyncGetTorqueOffsetRaw(::grpc::ClientContext* context, const ::H10WService::TorqueOffSetRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::H10WService::GetErrorCodeResponse>* AsyncGetJointErrorCodeRaw(::grpc::ClientContext* context, const ::H10WService::GetErrorCodeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::H10WService::GetErrorCodeResponse>* PrepareAsyncGetJointErrorCodeRaw(::grpc::ClientContext* context, const ::H10WService::GetErrorCodeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::H10WService::CalibrationResponse>* AsyncCalibrationZeroRaw(::grpc::ClientContext* context, const ::H10WService::CalibrationRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::H10WService::CalibrationResponse>* PrepareAsyncCalibrationZeroRaw(::grpc::ClientContext* context, const ::H10WService::CalibrationRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::H10WService::SaveParameterResponse>* AsyncSaveParameterRaw(::grpc::ClientContext* context, const ::H10WService::SaveParameterRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::H10WService::SaveParameterResponse>* PrepareAsyncSaveParameterRaw(::grpc::ClientContext* context, const ::H10WService::SaveParameterRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::H10WService::ClearErrorResponse>* AsyncClearErrorRaw(::grpc::ClientContext* context, const ::H10WService::ClearErrorRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::H10WService::ClearErrorResponse>* PrepareAsyncClearErrorRaw(::grpc::ClientContext* context, const ::H10WService::ClearErrorRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::H10WService::CalibrationResponse>* AsyncCalibration90DegRaw(::grpc::ClientContext* context, const ::H10WService::CalibrationRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::H10WService::CalibrationResponse>* PrepareAsyncCalibration90DegRaw(::grpc::ClientContext* context, const ::H10WService::CalibrationRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::H10WService::SetJointSoftLimitResponse>* AsyncSetJointSoftLimitRaw(::grpc::ClientContext* context, const ::H10WService::SetJointSoftLimitRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::H10WService::SetJointSoftLimitResponse>* PrepareAsyncSetJointSoftLimitRaw(::grpc::ClientContext* context, const ::H10WService::SetJointSoftLimitRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::H10WService::GetJointSoftLimitResponse>* AsyncGetJointSoftLimitRaw(::grpc::ClientContext* context, const ::H10WService::GetJointSoftLimitRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::H10WService::GetJointSoftLimitResponse>* PrepareAsyncGetJointSoftLimitRaw(::grpc::ClientContext* context, const ::H10WService::GetJointSoftLimitRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::H10WService::GetJointHardLimitResponse>* AsyncGetJointHardLimitRaw(::grpc::ClientContext* context, const ::H10WService::GetJointHardLimitRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::H10WService::GetJointHardLimitResponse>* PrepareAsyncGetJointHardLimitRaw(::grpc::ClientContext* context, const ::H10WService::GetJointHardLimitRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status ControlBrakeStatus(::grpc::ClientContext* context, const ::H10WService::BrakeControlRequest& request, ::H10WService::BrakeControlResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::H10WService::BrakeControlResponse>> AsyncControlBrakeStatus(::grpc::ClientContext* context, const ::H10WService::BrakeControlRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::H10WService::BrakeControlResponse>>(AsyncControlBrakeStatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::H10WService::BrakeControlResponse>> PrepareAsyncControlBrakeStatus(::grpc::ClientContext* context, const ::H10WService::BrakeControlRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::H10WService::BrakeControlResponse>>(PrepareAsyncControlBrakeStatusRaw(context, request, cq));
    }
    ::grpc::Status ControlPowerStatus(::grpc::ClientContext* context, const ::H10WService::PowerControlRequest& request, ::H10WService::PowerControlResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::H10WService::PowerControlResponse>> AsyncControlPowerStatus(::grpc::ClientContext* context, const ::H10WService::PowerControlRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::H10WService::PowerControlResponse>>(AsyncControlPowerStatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::H10WService::PowerControlResponse>> PrepareAsyncControlPowerStatus(::grpc::ClientContext* context, const ::H10WService::PowerControlRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::H10WService::PowerControlResponse>>(PrepareAsyncControlPowerStatusRaw(context, request, cq));
    }
    ::grpc::Status GetTorqueOffset(::grpc::ClientContext* context, const ::H10WService::TorqueOffSetRequest& request, ::H10WService::TorqueOffSetResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::H10WService::TorqueOffSetResponse>> AsyncGetTorqueOffset(::grpc::ClientContext* context, const ::H10WService::TorqueOffSetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::H10WService::TorqueOffSetResponse>>(AsyncGetTorqueOffsetRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::H10WService::TorqueOffSetResponse>> PrepareAsyncGetTorqueOffset(::grpc::ClientContext* context, const ::H10WService::TorqueOffSetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::H10WService::TorqueOffSetResponse>>(PrepareAsyncGetTorqueOffsetRaw(context, request, cq));
    }
    ::grpc::Status GetJointErrorCode(::grpc::ClientContext* context, const ::H10WService::GetErrorCodeRequest& request, ::H10WService::GetErrorCodeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::H10WService::GetErrorCodeResponse>> AsyncGetJointErrorCode(::grpc::ClientContext* context, const ::H10WService::GetErrorCodeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::H10WService::GetErrorCodeResponse>>(AsyncGetJointErrorCodeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::H10WService::GetErrorCodeResponse>> PrepareAsyncGetJointErrorCode(::grpc::ClientContext* context, const ::H10WService::GetErrorCodeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::H10WService::GetErrorCodeResponse>>(PrepareAsyncGetJointErrorCodeRaw(context, request, cq));
    }
    ::grpc::Status CalibrationZero(::grpc::ClientContext* context, const ::H10WService::CalibrationRequest& request, ::H10WService::CalibrationResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::H10WService::CalibrationResponse>> AsyncCalibrationZero(::grpc::ClientContext* context, const ::H10WService::CalibrationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::H10WService::CalibrationResponse>>(AsyncCalibrationZeroRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::H10WService::CalibrationResponse>> PrepareAsyncCalibrationZero(::grpc::ClientContext* context, const ::H10WService::CalibrationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::H10WService::CalibrationResponse>>(PrepareAsyncCalibrationZeroRaw(context, request, cq));
    }
    ::grpc::Status SaveParameter(::grpc::ClientContext* context, const ::H10WService::SaveParameterRequest& request, ::H10WService::SaveParameterResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::H10WService::SaveParameterResponse>> AsyncSaveParameter(::grpc::ClientContext* context, const ::H10WService::SaveParameterRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::H10WService::SaveParameterResponse>>(AsyncSaveParameterRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::H10WService::SaveParameterResponse>> PrepareAsyncSaveParameter(::grpc::ClientContext* context, const ::H10WService::SaveParameterRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::H10WService::SaveParameterResponse>>(PrepareAsyncSaveParameterRaw(context, request, cq));
    }
    ::grpc::Status ClearError(::grpc::ClientContext* context, const ::H10WService::ClearErrorRequest& request, ::H10WService::ClearErrorResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::H10WService::ClearErrorResponse>> AsyncClearError(::grpc::ClientContext* context, const ::H10WService::ClearErrorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::H10WService::ClearErrorResponse>>(AsyncClearErrorRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::H10WService::ClearErrorResponse>> PrepareAsyncClearError(::grpc::ClientContext* context, const ::H10WService::ClearErrorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::H10WService::ClearErrorResponse>>(PrepareAsyncClearErrorRaw(context, request, cq));
    }
    ::grpc::Status Calibration90Deg(::grpc::ClientContext* context, const ::H10WService::CalibrationRequest& request, ::H10WService::CalibrationResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::H10WService::CalibrationResponse>> AsyncCalibration90Deg(::grpc::ClientContext* context, const ::H10WService::CalibrationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::H10WService::CalibrationResponse>>(AsyncCalibration90DegRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::H10WService::CalibrationResponse>> PrepareAsyncCalibration90Deg(::grpc::ClientContext* context, const ::H10WService::CalibrationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::H10WService::CalibrationResponse>>(PrepareAsyncCalibration90DegRaw(context, request, cq));
    }
    ::grpc::Status SetJointSoftLimit(::grpc::ClientContext* context, const ::H10WService::SetJointSoftLimitRequest& request, ::H10WService::SetJointSoftLimitResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::H10WService::SetJointSoftLimitResponse>> AsyncSetJointSoftLimit(::grpc::ClientContext* context, const ::H10WService::SetJointSoftLimitRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::H10WService::SetJointSoftLimitResponse>>(AsyncSetJointSoftLimitRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::H10WService::SetJointSoftLimitResponse>> PrepareAsyncSetJointSoftLimit(::grpc::ClientContext* context, const ::H10WService::SetJointSoftLimitRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::H10WService::SetJointSoftLimitResponse>>(PrepareAsyncSetJointSoftLimitRaw(context, request, cq));
    }
    ::grpc::Status GetJointSoftLimit(::grpc::ClientContext* context, const ::H10WService::GetJointSoftLimitRequest& request, ::H10WService::GetJointSoftLimitResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::H10WService::GetJointSoftLimitResponse>> AsyncGetJointSoftLimit(::grpc::ClientContext* context, const ::H10WService::GetJointSoftLimitRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::H10WService::GetJointSoftLimitResponse>>(AsyncGetJointSoftLimitRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::H10WService::GetJointSoftLimitResponse>> PrepareAsyncGetJointSoftLimit(::grpc::ClientContext* context, const ::H10WService::GetJointSoftLimitRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::H10WService::GetJointSoftLimitResponse>>(PrepareAsyncGetJointSoftLimitRaw(context, request, cq));
    }
    ::grpc::Status GetJointHardLimit(::grpc::ClientContext* context, const ::H10WService::GetJointHardLimitRequest& request, ::H10WService::GetJointHardLimitResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::H10WService::GetJointHardLimitResponse>> AsyncGetJointHardLimit(::grpc::ClientContext* context, const ::H10WService::GetJointHardLimitRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::H10WService::GetJointHardLimitResponse>>(AsyncGetJointHardLimitRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::H10WService::GetJointHardLimitResponse>> PrepareAsyncGetJointHardLimit(::grpc::ClientContext* context, const ::H10WService::GetJointHardLimitRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::H10WService::GetJointHardLimitResponse>>(PrepareAsyncGetJointHardLimitRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void ControlBrakeStatus(::grpc::ClientContext* context, const ::H10WService::BrakeControlRequest* request, ::H10WService::BrakeControlResponse* response, std::function<void(::grpc::Status)>) override;
      void ControlBrakeStatus(::grpc::ClientContext* context, const ::H10WService::BrakeControlRequest* request, ::H10WService::BrakeControlResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ControlPowerStatus(::grpc::ClientContext* context, const ::H10WService::PowerControlRequest* request, ::H10WService::PowerControlResponse* response, std::function<void(::grpc::Status)>) override;
      void ControlPowerStatus(::grpc::ClientContext* context, const ::H10WService::PowerControlRequest* request, ::H10WService::PowerControlResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetTorqueOffset(::grpc::ClientContext* context, const ::H10WService::TorqueOffSetRequest* request, ::H10WService::TorqueOffSetResponse* response, std::function<void(::grpc::Status)>) override;
      void GetTorqueOffset(::grpc::ClientContext* context, const ::H10WService::TorqueOffSetRequest* request, ::H10WService::TorqueOffSetResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetJointErrorCode(::grpc::ClientContext* context, const ::H10WService::GetErrorCodeRequest* request, ::H10WService::GetErrorCodeResponse* response, std::function<void(::grpc::Status)>) override;
      void GetJointErrorCode(::grpc::ClientContext* context, const ::H10WService::GetErrorCodeRequest* request, ::H10WService::GetErrorCodeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void CalibrationZero(::grpc::ClientContext* context, const ::H10WService::CalibrationRequest* request, ::H10WService::CalibrationResponse* response, std::function<void(::grpc::Status)>) override;
      void CalibrationZero(::grpc::ClientContext* context, const ::H10WService::CalibrationRequest* request, ::H10WService::CalibrationResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SaveParameter(::grpc::ClientContext* context, const ::H10WService::SaveParameterRequest* request, ::H10WService::SaveParameterResponse* response, std::function<void(::grpc::Status)>) override;
      void SaveParameter(::grpc::ClientContext* context, const ::H10WService::SaveParameterRequest* request, ::H10WService::SaveParameterResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ClearError(::grpc::ClientContext* context, const ::H10WService::ClearErrorRequest* request, ::H10WService::ClearErrorResponse* response, std::function<void(::grpc::Status)>) override;
      void ClearError(::grpc::ClientContext* context, const ::H10WService::ClearErrorRequest* request, ::H10WService::ClearErrorResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Calibration90Deg(::grpc::ClientContext* context, const ::H10WService::CalibrationRequest* request, ::H10WService::CalibrationResponse* response, std::function<void(::grpc::Status)>) override;
      void Calibration90Deg(::grpc::ClientContext* context, const ::H10WService::CalibrationRequest* request, ::H10WService::CalibrationResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetJointSoftLimit(::grpc::ClientContext* context, const ::H10WService::SetJointSoftLimitRequest* request, ::H10WService::SetJointSoftLimitResponse* response, std::function<void(::grpc::Status)>) override;
      void SetJointSoftLimit(::grpc::ClientContext* context, const ::H10WService::SetJointSoftLimitRequest* request, ::H10WService::SetJointSoftLimitResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetJointSoftLimit(::grpc::ClientContext* context, const ::H10WService::GetJointSoftLimitRequest* request, ::H10WService::GetJointSoftLimitResponse* response, std::function<void(::grpc::Status)>) override;
      void GetJointSoftLimit(::grpc::ClientContext* context, const ::H10WService::GetJointSoftLimitRequest* request, ::H10WService::GetJointSoftLimitResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetJointHardLimit(::grpc::ClientContext* context, const ::H10WService::GetJointHardLimitRequest* request, ::H10WService::GetJointHardLimitResponse* response, std::function<void(::grpc::Status)>) override;
      void GetJointHardLimit(::grpc::ClientContext* context, const ::H10WService::GetJointHardLimitRequest* request, ::H10WService::GetJointHardLimitResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::H10WService::BrakeControlResponse>* AsyncControlBrakeStatusRaw(::grpc::ClientContext* context, const ::H10WService::BrakeControlRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::H10WService::BrakeControlResponse>* PrepareAsyncControlBrakeStatusRaw(::grpc::ClientContext* context, const ::H10WService::BrakeControlRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::H10WService::PowerControlResponse>* AsyncControlPowerStatusRaw(::grpc::ClientContext* context, const ::H10WService::PowerControlRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::H10WService::PowerControlResponse>* PrepareAsyncControlPowerStatusRaw(::grpc::ClientContext* context, const ::H10WService::PowerControlRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::H10WService::TorqueOffSetResponse>* AsyncGetTorqueOffsetRaw(::grpc::ClientContext* context, const ::H10WService::TorqueOffSetRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::H10WService::TorqueOffSetResponse>* PrepareAsyncGetTorqueOffsetRaw(::grpc::ClientContext* context, const ::H10WService::TorqueOffSetRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::H10WService::GetErrorCodeResponse>* AsyncGetJointErrorCodeRaw(::grpc::ClientContext* context, const ::H10WService::GetErrorCodeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::H10WService::GetErrorCodeResponse>* PrepareAsyncGetJointErrorCodeRaw(::grpc::ClientContext* context, const ::H10WService::GetErrorCodeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::H10WService::CalibrationResponse>* AsyncCalibrationZeroRaw(::grpc::ClientContext* context, const ::H10WService::CalibrationRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::H10WService::CalibrationResponse>* PrepareAsyncCalibrationZeroRaw(::grpc::ClientContext* context, const ::H10WService::CalibrationRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::H10WService::SaveParameterResponse>* AsyncSaveParameterRaw(::grpc::ClientContext* context, const ::H10WService::SaveParameterRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::H10WService::SaveParameterResponse>* PrepareAsyncSaveParameterRaw(::grpc::ClientContext* context, const ::H10WService::SaveParameterRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::H10WService::ClearErrorResponse>* AsyncClearErrorRaw(::grpc::ClientContext* context, const ::H10WService::ClearErrorRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::H10WService::ClearErrorResponse>* PrepareAsyncClearErrorRaw(::grpc::ClientContext* context, const ::H10WService::ClearErrorRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::H10WService::CalibrationResponse>* AsyncCalibration90DegRaw(::grpc::ClientContext* context, const ::H10WService::CalibrationRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::H10WService::CalibrationResponse>* PrepareAsyncCalibration90DegRaw(::grpc::ClientContext* context, const ::H10WService::CalibrationRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::H10WService::SetJointSoftLimitResponse>* AsyncSetJointSoftLimitRaw(::grpc::ClientContext* context, const ::H10WService::SetJointSoftLimitRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::H10WService::SetJointSoftLimitResponse>* PrepareAsyncSetJointSoftLimitRaw(::grpc::ClientContext* context, const ::H10WService::SetJointSoftLimitRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::H10WService::GetJointSoftLimitResponse>* AsyncGetJointSoftLimitRaw(::grpc::ClientContext* context, const ::H10WService::GetJointSoftLimitRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::H10WService::GetJointSoftLimitResponse>* PrepareAsyncGetJointSoftLimitRaw(::grpc::ClientContext* context, const ::H10WService::GetJointSoftLimitRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::H10WService::GetJointHardLimitResponse>* AsyncGetJointHardLimitRaw(::grpc::ClientContext* context, const ::H10WService::GetJointHardLimitRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::H10WService::GetJointHardLimitResponse>* PrepareAsyncGetJointHardLimitRaw(::grpc::ClientContext* context, const ::H10WService::GetJointHardLimitRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_ControlBrakeStatus_;
    const ::grpc::internal::RpcMethod rpcmethod_ControlPowerStatus_;
    const ::grpc::internal::RpcMethod rpcmethod_GetTorqueOffset_;
    const ::grpc::internal::RpcMethod rpcmethod_GetJointErrorCode_;
    const ::grpc::internal::RpcMethod rpcmethod_CalibrationZero_;
    const ::grpc::internal::RpcMethod rpcmethod_SaveParameter_;
    const ::grpc::internal::RpcMethod rpcmethod_ClearError_;
    const ::grpc::internal::RpcMethod rpcmethod_Calibration90Deg_;
    const ::grpc::internal::RpcMethod rpcmethod_SetJointSoftLimit_;
    const ::grpc::internal::RpcMethod rpcmethod_GetJointSoftLimit_;
    const ::grpc::internal::RpcMethod rpcmethod_GetJointHardLimit_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status ControlBrakeStatus(::grpc::ServerContext* context, const ::H10WService::BrakeControlRequest* request, ::H10WService::BrakeControlResponse* response);
    virtual ::grpc::Status ControlPowerStatus(::grpc::ServerContext* context, const ::H10WService::PowerControlRequest* request, ::H10WService::PowerControlResponse* response);
    virtual ::grpc::Status GetTorqueOffset(::grpc::ServerContext* context, const ::H10WService::TorqueOffSetRequest* request, ::H10WService::TorqueOffSetResponse* response);
    virtual ::grpc::Status GetJointErrorCode(::grpc::ServerContext* context, const ::H10WService::GetErrorCodeRequest* request, ::H10WService::GetErrorCodeResponse* response);
    virtual ::grpc::Status CalibrationZero(::grpc::ServerContext* context, const ::H10WService::CalibrationRequest* request, ::H10WService::CalibrationResponse* response);
    virtual ::grpc::Status SaveParameter(::grpc::ServerContext* context, const ::H10WService::SaveParameterRequest* request, ::H10WService::SaveParameterResponse* response);
    virtual ::grpc::Status ClearError(::grpc::ServerContext* context, const ::H10WService::ClearErrorRequest* request, ::H10WService::ClearErrorResponse* response);
    virtual ::grpc::Status Calibration90Deg(::grpc::ServerContext* context, const ::H10WService::CalibrationRequest* request, ::H10WService::CalibrationResponse* response);
    virtual ::grpc::Status SetJointSoftLimit(::grpc::ServerContext* context, const ::H10WService::SetJointSoftLimitRequest* request, ::H10WService::SetJointSoftLimitResponse* response);
    virtual ::grpc::Status GetJointSoftLimit(::grpc::ServerContext* context, const ::H10WService::GetJointSoftLimitRequest* request, ::H10WService::GetJointSoftLimitResponse* response);
    virtual ::grpc::Status GetJointHardLimit(::grpc::ServerContext* context, const ::H10WService::GetJointHardLimitRequest* request, ::H10WService::GetJointHardLimitResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_ControlBrakeStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ControlBrakeStatus() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_ControlBrakeStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ControlBrakeStatus(::grpc::ServerContext* /*context*/, const ::H10WService::BrakeControlRequest* /*request*/, ::H10WService::BrakeControlResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestControlBrakeStatus(::grpc::ServerContext* context, ::H10WService::BrakeControlRequest* request, ::grpc::ServerAsyncResponseWriter< ::H10WService::BrakeControlResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ControlPowerStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ControlPowerStatus() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_ControlPowerStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ControlPowerStatus(::grpc::ServerContext* /*context*/, const ::H10WService::PowerControlRequest* /*request*/, ::H10WService::PowerControlResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestControlPowerStatus(::grpc::ServerContext* context, ::H10WService::PowerControlRequest* request, ::grpc::ServerAsyncResponseWriter< ::H10WService::PowerControlResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetTorqueOffset : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetTorqueOffset() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_GetTorqueOffset() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTorqueOffset(::grpc::ServerContext* /*context*/, const ::H10WService::TorqueOffSetRequest* /*request*/, ::H10WService::TorqueOffSetResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetTorqueOffset(::grpc::ServerContext* context, ::H10WService::TorqueOffSetRequest* request, ::grpc::ServerAsyncResponseWriter< ::H10WService::TorqueOffSetResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetJointErrorCode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetJointErrorCode() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_GetJointErrorCode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetJointErrorCode(::grpc::ServerContext* /*context*/, const ::H10WService::GetErrorCodeRequest* /*request*/, ::H10WService::GetErrorCodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetJointErrorCode(::grpc::ServerContext* context, ::H10WService::GetErrorCodeRequest* request, ::grpc::ServerAsyncResponseWriter< ::H10WService::GetErrorCodeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CalibrationZero : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CalibrationZero() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_CalibrationZero() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CalibrationZero(::grpc::ServerContext* /*context*/, const ::H10WService::CalibrationRequest* /*request*/, ::H10WService::CalibrationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCalibrationZero(::grpc::ServerContext* context, ::H10WService::CalibrationRequest* request, ::grpc::ServerAsyncResponseWriter< ::H10WService::CalibrationResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SaveParameter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SaveParameter() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_SaveParameter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SaveParameter(::grpc::ServerContext* /*context*/, const ::H10WService::SaveParameterRequest* /*request*/, ::H10WService::SaveParameterResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSaveParameter(::grpc::ServerContext* context, ::H10WService::SaveParameterRequest* request, ::grpc::ServerAsyncResponseWriter< ::H10WService::SaveParameterResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ClearError : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ClearError() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_ClearError() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ClearError(::grpc::ServerContext* /*context*/, const ::H10WService::ClearErrorRequest* /*request*/, ::H10WService::ClearErrorResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestClearError(::grpc::ServerContext* context, ::H10WService::ClearErrorRequest* request, ::grpc::ServerAsyncResponseWriter< ::H10WService::ClearErrorResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Calibration90Deg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Calibration90Deg() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_Calibration90Deg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Calibration90Deg(::grpc::ServerContext* /*context*/, const ::H10WService::CalibrationRequest* /*request*/, ::H10WService::CalibrationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCalibration90Deg(::grpc::ServerContext* context, ::H10WService::CalibrationRequest* request, ::grpc::ServerAsyncResponseWriter< ::H10WService::CalibrationResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetJointSoftLimit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetJointSoftLimit() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_SetJointSoftLimit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetJointSoftLimit(::grpc::ServerContext* /*context*/, const ::H10WService::SetJointSoftLimitRequest* /*request*/, ::H10WService::SetJointSoftLimitResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetJointSoftLimit(::grpc::ServerContext* context, ::H10WService::SetJointSoftLimitRequest* request, ::grpc::ServerAsyncResponseWriter< ::H10WService::SetJointSoftLimitResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetJointSoftLimit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetJointSoftLimit() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_GetJointSoftLimit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetJointSoftLimit(::grpc::ServerContext* /*context*/, const ::H10WService::GetJointSoftLimitRequest* /*request*/, ::H10WService::GetJointSoftLimitResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetJointSoftLimit(::grpc::ServerContext* context, ::H10WService::GetJointSoftLimitRequest* request, ::grpc::ServerAsyncResponseWriter< ::H10WService::GetJointSoftLimitResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetJointHardLimit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetJointHardLimit() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_GetJointHardLimit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetJointHardLimit(::grpc::ServerContext* /*context*/, const ::H10WService::GetJointHardLimitRequest* /*request*/, ::H10WService::GetJointHardLimitResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetJointHardLimit(::grpc::ServerContext* context, ::H10WService::GetJointHardLimitRequest* request, ::grpc::ServerAsyncResponseWriter< ::H10WService::GetJointHardLimitResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_ControlBrakeStatus<WithAsyncMethod_ControlPowerStatus<WithAsyncMethod_GetTorqueOffset<WithAsyncMethod_GetJointErrorCode<WithAsyncMethod_CalibrationZero<WithAsyncMethod_SaveParameter<WithAsyncMethod_ClearError<WithAsyncMethod_Calibration90Deg<WithAsyncMethod_SetJointSoftLimit<WithAsyncMethod_GetJointSoftLimit<WithAsyncMethod_GetJointHardLimit<Service > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_ControlBrakeStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ControlBrakeStatus() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::H10WService::BrakeControlRequest, ::H10WService::BrakeControlResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::H10WService::BrakeControlRequest* request, ::H10WService::BrakeControlResponse* response) { return this->ControlBrakeStatus(context, request, response); }));}
    void SetMessageAllocatorFor_ControlBrakeStatus(
        ::grpc::MessageAllocator< ::H10WService::BrakeControlRequest, ::H10WService::BrakeControlResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::H10WService::BrakeControlRequest, ::H10WService::BrakeControlResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ControlBrakeStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ControlBrakeStatus(::grpc::ServerContext* /*context*/, const ::H10WService::BrakeControlRequest* /*request*/, ::H10WService::BrakeControlResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ControlBrakeStatus(
      ::grpc::CallbackServerContext* /*context*/, const ::H10WService::BrakeControlRequest* /*request*/, ::H10WService::BrakeControlResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ControlPowerStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ControlPowerStatus() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::H10WService::PowerControlRequest, ::H10WService::PowerControlResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::H10WService::PowerControlRequest* request, ::H10WService::PowerControlResponse* response) { return this->ControlPowerStatus(context, request, response); }));}
    void SetMessageAllocatorFor_ControlPowerStatus(
        ::grpc::MessageAllocator< ::H10WService::PowerControlRequest, ::H10WService::PowerControlResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::H10WService::PowerControlRequest, ::H10WService::PowerControlResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ControlPowerStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ControlPowerStatus(::grpc::ServerContext* /*context*/, const ::H10WService::PowerControlRequest* /*request*/, ::H10WService::PowerControlResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ControlPowerStatus(
      ::grpc::CallbackServerContext* /*context*/, const ::H10WService::PowerControlRequest* /*request*/, ::H10WService::PowerControlResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetTorqueOffset : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetTorqueOffset() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::H10WService::TorqueOffSetRequest, ::H10WService::TorqueOffSetResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::H10WService::TorqueOffSetRequest* request, ::H10WService::TorqueOffSetResponse* response) { return this->GetTorqueOffset(context, request, response); }));}
    void SetMessageAllocatorFor_GetTorqueOffset(
        ::grpc::MessageAllocator< ::H10WService::TorqueOffSetRequest, ::H10WService::TorqueOffSetResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::H10WService::TorqueOffSetRequest, ::H10WService::TorqueOffSetResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetTorqueOffset() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTorqueOffset(::grpc::ServerContext* /*context*/, const ::H10WService::TorqueOffSetRequest* /*request*/, ::H10WService::TorqueOffSetResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetTorqueOffset(
      ::grpc::CallbackServerContext* /*context*/, const ::H10WService::TorqueOffSetRequest* /*request*/, ::H10WService::TorqueOffSetResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetJointErrorCode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetJointErrorCode() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::H10WService::GetErrorCodeRequest, ::H10WService::GetErrorCodeResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::H10WService::GetErrorCodeRequest* request, ::H10WService::GetErrorCodeResponse* response) { return this->GetJointErrorCode(context, request, response); }));}
    void SetMessageAllocatorFor_GetJointErrorCode(
        ::grpc::MessageAllocator< ::H10WService::GetErrorCodeRequest, ::H10WService::GetErrorCodeResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::H10WService::GetErrorCodeRequest, ::H10WService::GetErrorCodeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetJointErrorCode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetJointErrorCode(::grpc::ServerContext* /*context*/, const ::H10WService::GetErrorCodeRequest* /*request*/, ::H10WService::GetErrorCodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetJointErrorCode(
      ::grpc::CallbackServerContext* /*context*/, const ::H10WService::GetErrorCodeRequest* /*request*/, ::H10WService::GetErrorCodeResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_CalibrationZero : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_CalibrationZero() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::H10WService::CalibrationRequest, ::H10WService::CalibrationResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::H10WService::CalibrationRequest* request, ::H10WService::CalibrationResponse* response) { return this->CalibrationZero(context, request, response); }));}
    void SetMessageAllocatorFor_CalibrationZero(
        ::grpc::MessageAllocator< ::H10WService::CalibrationRequest, ::H10WService::CalibrationResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::H10WService::CalibrationRequest, ::H10WService::CalibrationResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_CalibrationZero() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CalibrationZero(::grpc::ServerContext* /*context*/, const ::H10WService::CalibrationRequest* /*request*/, ::H10WService::CalibrationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CalibrationZero(
      ::grpc::CallbackServerContext* /*context*/, const ::H10WService::CalibrationRequest* /*request*/, ::H10WService::CalibrationResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SaveParameter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SaveParameter() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::H10WService::SaveParameterRequest, ::H10WService::SaveParameterResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::H10WService::SaveParameterRequest* request, ::H10WService::SaveParameterResponse* response) { return this->SaveParameter(context, request, response); }));}
    void SetMessageAllocatorFor_SaveParameter(
        ::grpc::MessageAllocator< ::H10WService::SaveParameterRequest, ::H10WService::SaveParameterResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::H10WService::SaveParameterRequest, ::H10WService::SaveParameterResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SaveParameter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SaveParameter(::grpc::ServerContext* /*context*/, const ::H10WService::SaveParameterRequest* /*request*/, ::H10WService::SaveParameterResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SaveParameter(
      ::grpc::CallbackServerContext* /*context*/, const ::H10WService::SaveParameterRequest* /*request*/, ::H10WService::SaveParameterResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ClearError : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ClearError() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::H10WService::ClearErrorRequest, ::H10WService::ClearErrorResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::H10WService::ClearErrorRequest* request, ::H10WService::ClearErrorResponse* response) { return this->ClearError(context, request, response); }));}
    void SetMessageAllocatorFor_ClearError(
        ::grpc::MessageAllocator< ::H10WService::ClearErrorRequest, ::H10WService::ClearErrorResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::H10WService::ClearErrorRequest, ::H10WService::ClearErrorResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ClearError() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ClearError(::grpc::ServerContext* /*context*/, const ::H10WService::ClearErrorRequest* /*request*/, ::H10WService::ClearErrorResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ClearError(
      ::grpc::CallbackServerContext* /*context*/, const ::H10WService::ClearErrorRequest* /*request*/, ::H10WService::ClearErrorResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Calibration90Deg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Calibration90Deg() {
      ::grpc::Service::MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::H10WService::CalibrationRequest, ::H10WService::CalibrationResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::H10WService::CalibrationRequest* request, ::H10WService::CalibrationResponse* response) { return this->Calibration90Deg(context, request, response); }));}
    void SetMessageAllocatorFor_Calibration90Deg(
        ::grpc::MessageAllocator< ::H10WService::CalibrationRequest, ::H10WService::CalibrationResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::H10WService::CalibrationRequest, ::H10WService::CalibrationResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Calibration90Deg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Calibration90Deg(::grpc::ServerContext* /*context*/, const ::H10WService::CalibrationRequest* /*request*/, ::H10WService::CalibrationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Calibration90Deg(
      ::grpc::CallbackServerContext* /*context*/, const ::H10WService::CalibrationRequest* /*request*/, ::H10WService::CalibrationResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetJointSoftLimit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetJointSoftLimit() {
      ::grpc::Service::MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::H10WService::SetJointSoftLimitRequest, ::H10WService::SetJointSoftLimitResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::H10WService::SetJointSoftLimitRequest* request, ::H10WService::SetJointSoftLimitResponse* response) { return this->SetJointSoftLimit(context, request, response); }));}
    void SetMessageAllocatorFor_SetJointSoftLimit(
        ::grpc::MessageAllocator< ::H10WService::SetJointSoftLimitRequest, ::H10WService::SetJointSoftLimitResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::H10WService::SetJointSoftLimitRequest, ::H10WService::SetJointSoftLimitResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetJointSoftLimit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetJointSoftLimit(::grpc::ServerContext* /*context*/, const ::H10WService::SetJointSoftLimitRequest* /*request*/, ::H10WService::SetJointSoftLimitResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetJointSoftLimit(
      ::grpc::CallbackServerContext* /*context*/, const ::H10WService::SetJointSoftLimitRequest* /*request*/, ::H10WService::SetJointSoftLimitResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetJointSoftLimit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetJointSoftLimit() {
      ::grpc::Service::MarkMethodCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::H10WService::GetJointSoftLimitRequest, ::H10WService::GetJointSoftLimitResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::H10WService::GetJointSoftLimitRequest* request, ::H10WService::GetJointSoftLimitResponse* response) { return this->GetJointSoftLimit(context, request, response); }));}
    void SetMessageAllocatorFor_GetJointSoftLimit(
        ::grpc::MessageAllocator< ::H10WService::GetJointSoftLimitRequest, ::H10WService::GetJointSoftLimitResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::H10WService::GetJointSoftLimitRequest, ::H10WService::GetJointSoftLimitResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetJointSoftLimit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetJointSoftLimit(::grpc::ServerContext* /*context*/, const ::H10WService::GetJointSoftLimitRequest* /*request*/, ::H10WService::GetJointSoftLimitResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetJointSoftLimit(
      ::grpc::CallbackServerContext* /*context*/, const ::H10WService::GetJointSoftLimitRequest* /*request*/, ::H10WService::GetJointSoftLimitResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetJointHardLimit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetJointHardLimit() {
      ::grpc::Service::MarkMethodCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::H10WService::GetJointHardLimitRequest, ::H10WService::GetJointHardLimitResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::H10WService::GetJointHardLimitRequest* request, ::H10WService::GetJointHardLimitResponse* response) { return this->GetJointHardLimit(context, request, response); }));}
    void SetMessageAllocatorFor_GetJointHardLimit(
        ::grpc::MessageAllocator< ::H10WService::GetJointHardLimitRequest, ::H10WService::GetJointHardLimitResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::H10WService::GetJointHardLimitRequest, ::H10WService::GetJointHardLimitResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetJointHardLimit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetJointHardLimit(::grpc::ServerContext* /*context*/, const ::H10WService::GetJointHardLimitRequest* /*request*/, ::H10WService::GetJointHardLimitResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetJointHardLimit(
      ::grpc::CallbackServerContext* /*context*/, const ::H10WService::GetJointHardLimitRequest* /*request*/, ::H10WService::GetJointHardLimitResponse* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_ControlBrakeStatus<WithCallbackMethod_ControlPowerStatus<WithCallbackMethod_GetTorqueOffset<WithCallbackMethod_GetJointErrorCode<WithCallbackMethod_CalibrationZero<WithCallbackMethod_SaveParameter<WithCallbackMethod_ClearError<WithCallbackMethod_Calibration90Deg<WithCallbackMethod_SetJointSoftLimit<WithCallbackMethod_GetJointSoftLimit<WithCallbackMethod_GetJointHardLimit<Service > > > > > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_ControlBrakeStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ControlBrakeStatus() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_ControlBrakeStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ControlBrakeStatus(::grpc::ServerContext* /*context*/, const ::H10WService::BrakeControlRequest* /*request*/, ::H10WService::BrakeControlResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ControlPowerStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ControlPowerStatus() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_ControlPowerStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ControlPowerStatus(::grpc::ServerContext* /*context*/, const ::H10WService::PowerControlRequest* /*request*/, ::H10WService::PowerControlResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetTorqueOffset : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetTorqueOffset() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_GetTorqueOffset() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTorqueOffset(::grpc::ServerContext* /*context*/, const ::H10WService::TorqueOffSetRequest* /*request*/, ::H10WService::TorqueOffSetResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetJointErrorCode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetJointErrorCode() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_GetJointErrorCode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetJointErrorCode(::grpc::ServerContext* /*context*/, const ::H10WService::GetErrorCodeRequest* /*request*/, ::H10WService::GetErrorCodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CalibrationZero : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CalibrationZero() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_CalibrationZero() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CalibrationZero(::grpc::ServerContext* /*context*/, const ::H10WService::CalibrationRequest* /*request*/, ::H10WService::CalibrationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SaveParameter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SaveParameter() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_SaveParameter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SaveParameter(::grpc::ServerContext* /*context*/, const ::H10WService::SaveParameterRequest* /*request*/, ::H10WService::SaveParameterResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ClearError : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ClearError() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_ClearError() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ClearError(::grpc::ServerContext* /*context*/, const ::H10WService::ClearErrorRequest* /*request*/, ::H10WService::ClearErrorResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Calibration90Deg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Calibration90Deg() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_Calibration90Deg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Calibration90Deg(::grpc::ServerContext* /*context*/, const ::H10WService::CalibrationRequest* /*request*/, ::H10WService::CalibrationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetJointSoftLimit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetJointSoftLimit() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_SetJointSoftLimit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetJointSoftLimit(::grpc::ServerContext* /*context*/, const ::H10WService::SetJointSoftLimitRequest* /*request*/, ::H10WService::SetJointSoftLimitResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetJointSoftLimit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetJointSoftLimit() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_GetJointSoftLimit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetJointSoftLimit(::grpc::ServerContext* /*context*/, const ::H10WService::GetJointSoftLimitRequest* /*request*/, ::H10WService::GetJointSoftLimitResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetJointHardLimit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetJointHardLimit() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_GetJointHardLimit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetJointHardLimit(::grpc::ServerContext* /*context*/, const ::H10WService::GetJointHardLimitRequest* /*request*/, ::H10WService::GetJointHardLimitResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_ControlBrakeStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ControlBrakeStatus() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_ControlBrakeStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ControlBrakeStatus(::grpc::ServerContext* /*context*/, const ::H10WService::BrakeControlRequest* /*request*/, ::H10WService::BrakeControlResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestControlBrakeStatus(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ControlPowerStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ControlPowerStatus() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_ControlPowerStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ControlPowerStatus(::grpc::ServerContext* /*context*/, const ::H10WService::PowerControlRequest* /*request*/, ::H10WService::PowerControlResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestControlPowerStatus(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetTorqueOffset : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetTorqueOffset() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_GetTorqueOffset() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTorqueOffset(::grpc::ServerContext* /*context*/, const ::H10WService::TorqueOffSetRequest* /*request*/, ::H10WService::TorqueOffSetResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetTorqueOffset(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetJointErrorCode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetJointErrorCode() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_GetJointErrorCode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetJointErrorCode(::grpc::ServerContext* /*context*/, const ::H10WService::GetErrorCodeRequest* /*request*/, ::H10WService::GetErrorCodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetJointErrorCode(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CalibrationZero : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CalibrationZero() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_CalibrationZero() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CalibrationZero(::grpc::ServerContext* /*context*/, const ::H10WService::CalibrationRequest* /*request*/, ::H10WService::CalibrationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCalibrationZero(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SaveParameter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SaveParameter() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_SaveParameter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SaveParameter(::grpc::ServerContext* /*context*/, const ::H10WService::SaveParameterRequest* /*request*/, ::H10WService::SaveParameterResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSaveParameter(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ClearError : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ClearError() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_ClearError() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ClearError(::grpc::ServerContext* /*context*/, const ::H10WService::ClearErrorRequest* /*request*/, ::H10WService::ClearErrorResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestClearError(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Calibration90Deg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Calibration90Deg() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_Calibration90Deg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Calibration90Deg(::grpc::ServerContext* /*context*/, const ::H10WService::CalibrationRequest* /*request*/, ::H10WService::CalibrationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCalibration90Deg(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetJointSoftLimit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetJointSoftLimit() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_SetJointSoftLimit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetJointSoftLimit(::grpc::ServerContext* /*context*/, const ::H10WService::SetJointSoftLimitRequest* /*request*/, ::H10WService::SetJointSoftLimitResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetJointSoftLimit(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetJointSoftLimit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetJointSoftLimit() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_GetJointSoftLimit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetJointSoftLimit(::grpc::ServerContext* /*context*/, const ::H10WService::GetJointSoftLimitRequest* /*request*/, ::H10WService::GetJointSoftLimitResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetJointSoftLimit(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetJointHardLimit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetJointHardLimit() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_GetJointHardLimit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetJointHardLimit(::grpc::ServerContext* /*context*/, const ::H10WService::GetJointHardLimitRequest* /*request*/, ::H10WService::GetJointHardLimitResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetJointHardLimit(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ControlBrakeStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ControlBrakeStatus() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ControlBrakeStatus(context, request, response); }));
    }
    ~WithRawCallbackMethod_ControlBrakeStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ControlBrakeStatus(::grpc::ServerContext* /*context*/, const ::H10WService::BrakeControlRequest* /*request*/, ::H10WService::BrakeControlResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ControlBrakeStatus(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ControlPowerStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ControlPowerStatus() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ControlPowerStatus(context, request, response); }));
    }
    ~WithRawCallbackMethod_ControlPowerStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ControlPowerStatus(::grpc::ServerContext* /*context*/, const ::H10WService::PowerControlRequest* /*request*/, ::H10WService::PowerControlResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ControlPowerStatus(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetTorqueOffset : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetTorqueOffset() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetTorqueOffset(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetTorqueOffset() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTorqueOffset(::grpc::ServerContext* /*context*/, const ::H10WService::TorqueOffSetRequest* /*request*/, ::H10WService::TorqueOffSetResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetTorqueOffset(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetJointErrorCode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetJointErrorCode() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetJointErrorCode(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetJointErrorCode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetJointErrorCode(::grpc::ServerContext* /*context*/, const ::H10WService::GetErrorCodeRequest* /*request*/, ::H10WService::GetErrorCodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetJointErrorCode(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_CalibrationZero : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_CalibrationZero() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CalibrationZero(context, request, response); }));
    }
    ~WithRawCallbackMethod_CalibrationZero() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CalibrationZero(::grpc::ServerContext* /*context*/, const ::H10WService::CalibrationRequest* /*request*/, ::H10WService::CalibrationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CalibrationZero(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SaveParameter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SaveParameter() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SaveParameter(context, request, response); }));
    }
    ~WithRawCallbackMethod_SaveParameter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SaveParameter(::grpc::ServerContext* /*context*/, const ::H10WService::SaveParameterRequest* /*request*/, ::H10WService::SaveParameterResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SaveParameter(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ClearError : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ClearError() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ClearError(context, request, response); }));
    }
    ~WithRawCallbackMethod_ClearError() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ClearError(::grpc::ServerContext* /*context*/, const ::H10WService::ClearErrorRequest* /*request*/, ::H10WService::ClearErrorResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ClearError(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Calibration90Deg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Calibration90Deg() {
      ::grpc::Service::MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Calibration90Deg(context, request, response); }));
    }
    ~WithRawCallbackMethod_Calibration90Deg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Calibration90Deg(::grpc::ServerContext* /*context*/, const ::H10WService::CalibrationRequest* /*request*/, ::H10WService::CalibrationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Calibration90Deg(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetJointSoftLimit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetJointSoftLimit() {
      ::grpc::Service::MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetJointSoftLimit(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetJointSoftLimit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetJointSoftLimit(::grpc::ServerContext* /*context*/, const ::H10WService::SetJointSoftLimitRequest* /*request*/, ::H10WService::SetJointSoftLimitResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetJointSoftLimit(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetJointSoftLimit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetJointSoftLimit() {
      ::grpc::Service::MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetJointSoftLimit(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetJointSoftLimit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetJointSoftLimit(::grpc::ServerContext* /*context*/, const ::H10WService::GetJointSoftLimitRequest* /*request*/, ::H10WService::GetJointSoftLimitResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetJointSoftLimit(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetJointHardLimit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetJointHardLimit() {
      ::grpc::Service::MarkMethodRawCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetJointHardLimit(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetJointHardLimit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetJointHardLimit(::grpc::ServerContext* /*context*/, const ::H10WService::GetJointHardLimitRequest* /*request*/, ::H10WService::GetJointHardLimitResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetJointHardLimit(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ControlBrakeStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ControlBrakeStatus() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::H10WService::BrakeControlRequest, ::H10WService::BrakeControlResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::H10WService::BrakeControlRequest, ::H10WService::BrakeControlResponse>* streamer) {
                       return this->StreamedControlBrakeStatus(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ControlBrakeStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ControlBrakeStatus(::grpc::ServerContext* /*context*/, const ::H10WService::BrakeControlRequest* /*request*/, ::H10WService::BrakeControlResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedControlBrakeStatus(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::H10WService::BrakeControlRequest,::H10WService::BrakeControlResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ControlPowerStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ControlPowerStatus() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::H10WService::PowerControlRequest, ::H10WService::PowerControlResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::H10WService::PowerControlRequest, ::H10WService::PowerControlResponse>* streamer) {
                       return this->StreamedControlPowerStatus(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ControlPowerStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ControlPowerStatus(::grpc::ServerContext* /*context*/, const ::H10WService::PowerControlRequest* /*request*/, ::H10WService::PowerControlResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedControlPowerStatus(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::H10WService::PowerControlRequest,::H10WService::PowerControlResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetTorqueOffset : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetTorqueOffset() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::H10WService::TorqueOffSetRequest, ::H10WService::TorqueOffSetResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::H10WService::TorqueOffSetRequest, ::H10WService::TorqueOffSetResponse>* streamer) {
                       return this->StreamedGetTorqueOffset(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetTorqueOffset() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetTorqueOffset(::grpc::ServerContext* /*context*/, const ::H10WService::TorqueOffSetRequest* /*request*/, ::H10WService::TorqueOffSetResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetTorqueOffset(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::H10WService::TorqueOffSetRequest,::H10WService::TorqueOffSetResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetJointErrorCode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetJointErrorCode() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::H10WService::GetErrorCodeRequest, ::H10WService::GetErrorCodeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::H10WService::GetErrorCodeRequest, ::H10WService::GetErrorCodeResponse>* streamer) {
                       return this->StreamedGetJointErrorCode(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetJointErrorCode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetJointErrorCode(::grpc::ServerContext* /*context*/, const ::H10WService::GetErrorCodeRequest* /*request*/, ::H10WService::GetErrorCodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetJointErrorCode(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::H10WService::GetErrorCodeRequest,::H10WService::GetErrorCodeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CalibrationZero : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CalibrationZero() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::H10WService::CalibrationRequest, ::H10WService::CalibrationResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::H10WService::CalibrationRequest, ::H10WService::CalibrationResponse>* streamer) {
                       return this->StreamedCalibrationZero(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CalibrationZero() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CalibrationZero(::grpc::ServerContext* /*context*/, const ::H10WService::CalibrationRequest* /*request*/, ::H10WService::CalibrationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCalibrationZero(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::H10WService::CalibrationRequest,::H10WService::CalibrationResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SaveParameter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SaveParameter() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::H10WService::SaveParameterRequest, ::H10WService::SaveParameterResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::H10WService::SaveParameterRequest, ::H10WService::SaveParameterResponse>* streamer) {
                       return this->StreamedSaveParameter(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SaveParameter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SaveParameter(::grpc::ServerContext* /*context*/, const ::H10WService::SaveParameterRequest* /*request*/, ::H10WService::SaveParameterResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSaveParameter(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::H10WService::SaveParameterRequest,::H10WService::SaveParameterResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ClearError : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ClearError() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::H10WService::ClearErrorRequest, ::H10WService::ClearErrorResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::H10WService::ClearErrorRequest, ::H10WService::ClearErrorResponse>* streamer) {
                       return this->StreamedClearError(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ClearError() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ClearError(::grpc::ServerContext* /*context*/, const ::H10WService::ClearErrorRequest* /*request*/, ::H10WService::ClearErrorResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedClearError(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::H10WService::ClearErrorRequest,::H10WService::ClearErrorResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Calibration90Deg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Calibration90Deg() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::H10WService::CalibrationRequest, ::H10WService::CalibrationResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::H10WService::CalibrationRequest, ::H10WService::CalibrationResponse>* streamer) {
                       return this->StreamedCalibration90Deg(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Calibration90Deg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Calibration90Deg(::grpc::ServerContext* /*context*/, const ::H10WService::CalibrationRequest* /*request*/, ::H10WService::CalibrationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCalibration90Deg(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::H10WService::CalibrationRequest,::H10WService::CalibrationResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetJointSoftLimit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetJointSoftLimit() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::H10WService::SetJointSoftLimitRequest, ::H10WService::SetJointSoftLimitResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::H10WService::SetJointSoftLimitRequest, ::H10WService::SetJointSoftLimitResponse>* streamer) {
                       return this->StreamedSetJointSoftLimit(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetJointSoftLimit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetJointSoftLimit(::grpc::ServerContext* /*context*/, const ::H10WService::SetJointSoftLimitRequest* /*request*/, ::H10WService::SetJointSoftLimitResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetJointSoftLimit(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::H10WService::SetJointSoftLimitRequest,::H10WService::SetJointSoftLimitResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetJointSoftLimit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetJointSoftLimit() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::H10WService::GetJointSoftLimitRequest, ::H10WService::GetJointSoftLimitResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::H10WService::GetJointSoftLimitRequest, ::H10WService::GetJointSoftLimitResponse>* streamer) {
                       return this->StreamedGetJointSoftLimit(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetJointSoftLimit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetJointSoftLimit(::grpc::ServerContext* /*context*/, const ::H10WService::GetJointSoftLimitRequest* /*request*/, ::H10WService::GetJointSoftLimitResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetJointSoftLimit(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::H10WService::GetJointSoftLimitRequest,::H10WService::GetJointSoftLimitResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetJointHardLimit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetJointHardLimit() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler<
          ::H10WService::GetJointHardLimitRequest, ::H10WService::GetJointHardLimitResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::H10WService::GetJointHardLimitRequest, ::H10WService::GetJointHardLimitResponse>* streamer) {
                       return this->StreamedGetJointHardLimit(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetJointHardLimit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetJointHardLimit(::grpc::ServerContext* /*context*/, const ::H10WService::GetJointHardLimitRequest* /*request*/, ::H10WService::GetJointHardLimitResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetJointHardLimit(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::H10WService::GetJointHardLimitRequest,::H10WService::GetJointHardLimitResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_ControlBrakeStatus<WithStreamedUnaryMethod_ControlPowerStatus<WithStreamedUnaryMethod_GetTorqueOffset<WithStreamedUnaryMethod_GetJointErrorCode<WithStreamedUnaryMethod_CalibrationZero<WithStreamedUnaryMethod_SaveParameter<WithStreamedUnaryMethod_ClearError<WithStreamedUnaryMethod_Calibration90Deg<WithStreamedUnaryMethod_SetJointSoftLimit<WithStreamedUnaryMethod_GetJointSoftLimit<WithStreamedUnaryMethod_GetJointHardLimit<Service > > > > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_ControlBrakeStatus<WithStreamedUnaryMethod_ControlPowerStatus<WithStreamedUnaryMethod_GetTorqueOffset<WithStreamedUnaryMethod_GetJointErrorCode<WithStreamedUnaryMethod_CalibrationZero<WithStreamedUnaryMethod_SaveParameter<WithStreamedUnaryMethod_ClearError<WithStreamedUnaryMethod_Calibration90Deg<WithStreamedUnaryMethod_SetJointSoftLimit<WithStreamedUnaryMethod_GetJointSoftLimit<WithStreamedUnaryMethod_GetJointHardLimit<Service > > > > > > > > > > > StreamedService;
};

}  // namespace H10WService


#include <grpcpp/ports_undef.inc>
#endif  // GRPC_Service_2eproto__INCLUDED
